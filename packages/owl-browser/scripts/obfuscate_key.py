#!/usr/bin/env python3
"""
Obfuscate the RSA public key for embedding in the binary.
This prevents simple `strings` extraction of the key.

Usage:
  python3 obfuscate_key.py                    # Use default key path ~/.owl_license/owl_license.pub
  python3 obfuscate_key.py /path/to/key.pub   # Use specified key path
  python3 obfuscate_key.py --check            # Verify current embedded key matches key file
"""

import sys
import os

# XOR key for obfuscation (must match kObfuscationKey in owl_license.cc)
OBFUSCATION_KEY = bytes([
    0x5A, 0x3C, 0x7F, 0x1E, 0x9D, 0x4B, 0x2A, 0x8E,
    0xF1, 0x63, 0xC5, 0x07, 0xB9, 0x72, 0xD4, 0x16
])

DEFAULT_KEY_PATH = os.path.expanduser("~/.owl_license/owl_license.pub")


def get_public_key(key_path: str = None) -> str:
    """Read public key from file."""
    path = key_path or DEFAULT_KEY_PATH

    if not os.path.exists(path):
        print(f"ERROR: Public key not found at: {path}", file=sys.stderr)
        print(f"", file=sys.stderr)
        print(f"To generate a key pair, run:", file=sys.stderr)
        print(f"  ./build/license/license_generator keygen", file=sys.stderr)
        sys.exit(1)

    with open(path, 'r') as f:
        content = f.read().strip()

    # Validate it looks like a PEM public key
    if not content.startswith("-----BEGIN PUBLIC KEY-----"):
        print(f"ERROR: File does not appear to be a valid PEM public key: {path}", file=sys.stderr)
        sys.exit(1)

    if not content.endswith("-----END PUBLIC KEY-----"):
        print(f"ERROR: File does not appear to be a valid PEM public key: {path}", file=sys.stderr)
        sys.exit(1)

    return content


def obfuscate(plaintext: bytes) -> bytes:
    """XOR plaintext with the obfuscation key."""
    result = bytearray()
    key_len = len(OBFUSCATION_KEY)
    for i, byte in enumerate(plaintext):
        result.append(byte ^ OBFUSCATION_KEY[i % key_len])
    return bytes(result)


def deobfuscate(ciphertext: bytes) -> bytes:
    """XOR is symmetric, so same function works for deobfuscation."""
    return obfuscate(ciphertext)


def format_c_array(data: bytes, name: str, bytes_per_line: int = 12) -> str:
    """Format bytes as a C array."""
    lines = []
    lines.append(f"static const uint8_t {name}[] = {{")

    for i in range(0, len(data), bytes_per_line):
        chunk = data[i:i + bytes_per_line]
        hex_bytes = ", ".join(f"0x{b:02x}" for b in chunk)
        if i + bytes_per_line < len(data):
            hex_bytes += ","
        lines.append(f"    {hex_bytes}")

    lines.append("};")
    lines.append(f"static const size_t {name}Size = {len(data)};")
    return "\n".join(lines)


def main():
    # Parse arguments
    key_path = None
    check_mode = False

    for arg in sys.argv[1:]:
        if arg == "--check":
            check_mode = True
        elif arg == "--help" or arg == "-h":
            print(__doc__)
            return 0
        elif not arg.startswith("-"):
            key_path = arg
        else:
            print(f"Unknown argument: {arg}", file=sys.stderr)
            print(__doc__)
            return 1

    # Get public key
    public_key = get_public_key(key_path)
    key_bytes = public_key.encode('utf-8')

    # Obfuscate
    obfuscated = obfuscate(key_bytes)

    # Verify deobfuscation works
    deobfuscated = deobfuscate(obfuscated)
    assert deobfuscated == key_bytes, "Deobfuscation failed!"

    if check_mode:
        # Just verify the key is valid
        print(f"Public key loaded from: {key_path or DEFAULT_KEY_PATH}")
        print(f"Key size: {len(key_bytes)} bytes")
        print(f"Obfuscated size: {len(obfuscated)} bytes")
        print("Verification: OK")
        return 0

    # Output C array
    print("// Auto-generated by obfuscate_key.py - DO NOT EDIT MANUALLY")
    print(f"// Source: {key_path or DEFAULT_KEY_PATH}")
    print(f"// Run: python3 scripts/obfuscate_key.py")
    print()
    print(format_c_array(obfuscated, "kObfuscatedPublicKey"))
    print()
    print(f"// Original key size: {len(key_bytes)} bytes")
    print()
    print("// Verification: The deobfuscated key should start with:")
    print("// " + public_key.split('\n')[0])

    return 0


if __name__ == "__main__":
    sys.exit(main())
