/**
 * Owl Browser License Manager Implementation
 *
 * Implements RSA-2048 signature verification and AES-256 encryption
 * for secure license validation with anti-tampering measures.
 *
 * Note: CEF is compiled with exceptions disabled, so this code uses
 * return values instead of exceptions for error handling.
 */

#include "owl_license.h"
#include "logger.h"

#include <fstream>
#include <sstream>
#include <iomanip>
#include <cstring>
#include <random>
#include <chrono>
#include <thread>
#include <atomic>
#include <ctime>
#include <sys/stat.h>

// HTTP client for subscription server communication
#include <curl/curl.h>

#if defined(OS_MACOS)
#include <CommonCrypto/CommonCrypto.h>
#include <CommonCrypto/CommonRandom.h>
#include <Security/Security.h>
#include <IOKit/IOKitLib.h>
#include <sys/sysctl.h>
#include <sys/ptrace.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#include <mach-o/dyld.h>
#include <dlfcn.h>
#include <unistd.h>
#elif defined(OS_LINUX)
#include <openssl/evp.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <openssl/hmac.h>
#include <sys/ptrace.h>
#include <sys/utsname.h>
#include <unistd.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <linux/if.h>
#elif defined(OS_WINDOWS)
#include <windows.h>
#include <wincrypt.h>
#include <iphlpapi.h>
#include <intrin.h>
#include <direct.h>
#pragma comment(lib, "crypt32.lib")
#pragma comment(lib, "iphlpapi.lib")
#endif

namespace olib {
namespace license {

// ============================================================================
// Security Hardening: Obfuscated Public Key Storage
// ============================================================================
// The public key is stored in an obfuscated format to prevent easy extraction
// via `strings` command. It's XOR'd with a compile-time key and reconstructed
// at runtime.

namespace {

// XOR key for obfuscation (changes the binary representation)
constexpr uint8_t kObfuscationKey[] = {
    0x5A, 0x3C, 0x7F, 0x1E, 0x9D, 0x4B, 0x2A, 0x8E,
    0xF1, 0x63, 0xC5, 0x07, 0xB9, 0x72, 0xD4, 0x16
};

// Obfuscated public key bytes (XOR'd with kObfuscationKey)
// Original: RSA-2048 public key in PEM format
// Generated by scripts/obfuscate_key.py - DO NOT EDIT MANUALLY
static const uint8_t kObfuscatedPublicKey[] = {
    0x77, 0x11, 0x52, 0x33, 0xb0, 0x09, 0x6f, 0xc9, 0xb8, 0x2d, 0xe5, 0x57,
    0xec, 0x30, 0x98, 0x5f, 0x19, 0x1c, 0x34, 0x5b, 0xc4, 0x66, 0x07, 0xa3,
    0xdc, 0x4e, 0xcf, 0x4a, 0xf0, 0x3b, 0x96, 0x5f, 0x30, 0x7d, 0x31, 0x5c,
    0xfa, 0x20, 0x5b, 0xe6, 0x9a, 0x0a, 0x82, 0x3e, 0xce, 0x42, 0x96, 0x57,
    0x0b, 0x79, 0x39, 0x5f, 0xdc, 0x04, 0x69, 0xcf, 0xa0, 0x5b, 0x84, 0x4a,
    0xf0, 0x3b, 0x96, 0x55, 0x3d, 0x77, 0x3c, 0x5f, 0xcc, 0x0e, 0x6b, 0xe1,
    0xb8, 0x36, 0x80, 0x4a, 0xdb, 0x28, 0xe4, 0x64, 0x3d, 0x0f, 0x35, 0x6c,
    0xf0, 0x21, 0x61, 0xe3, 0x9e, 0x06, 0x8a, 0x0d, 0xec, 0x46, 0xa5, 0x54,
    0x14, 0x09, 0x26, 0x6e, 0xc5, 0x32, 0x49, 0xec, 0x97, 0x07, 0xae, 0x60,
    0x92, 0x39, 0x8c, 0x6f, 0x2b, 0x56, 0x1b, 0x6a, 0xea, 0x20, 0x7f, 0xb9,
    0xab, 0x57, 0xf6, 0x7e, 0xf4, 0x01, 0xb0, 0x71, 0x6b, 0x0c, 0x0e, 0x46,
    0xe8, 0x13, 0x59, 0xdc, 0x93, 0x32, 0x8f, 0x51, 0xce, 0x47, 0xbe, 0x5a,
    0x37, 0x70, 0x34, 0x75, 0xe7, 0x11, 0x7e, 0xba, 0x87, 0x5b, 0x83, 0x31,
    0xb3, 0x27, 0xb0, 0x2e, 0x23, 0x0a, 0x1b, 0x54, 0xfe, 0x03, 0x7f, 0xa1,
    0x80, 0x36, 0xae, 0x6c, 0xf6, 0x1b, 0xa5, 0x21, 0x17, 0x4e, 0x12, 0x6b,
    0xab, 0x23, 0x1b, 0xe5, 0xab, 0x57, 0x84, 0x4f, 0x80, 0x20, 0x86, 0x5c,
    0x0e, 0x79, 0x4e, 0x2e, 0xf7, 0x05, 0x40, 0xde, 0xbc, 0x14, 0xa8, 0x60,
    0xf6, 0x44, 0xb3, 0x40, 0x3f, 0x46, 0x2b, 0x4f, 0xd5, 0x04, 0x1b, 0xc1,
    0x82, 0x02, 0xf0, 0x63, 0xe8, 0x78, 0x90, 0x46, 0x11, 0x0a, 0x1b, 0x58,
    0xfb, 0x7d, 0x43, 0xfe, 0xa5, 0x2b, 0xbd, 0x75, 0xf1, 0x1f, 0x9c, 0x75,
    0x1d, 0x4b, 0x1c, 0x76, 0xef, 0x13, 0x7c, 0xe9, 0xa4, 0x07, 0xa9, 0x4a,
    0x89, 0x3f, 0x80, 0x24, 0x2a, 0x7a, 0x0e, 0x6b, 0xca, 0x25, 0x49, 0xdc,
    0xbb, 0x2b, 0x8a, 0x6c, 0xd1, 0x21, 0xb3, 0x46, 0x62, 0x6e, 0x49, 0x35,
    0xdc, 0x0f, 0x18, 0xc4, 0xc6, 0x10, 0xb7, 0x28, 0xd8, 0x0a, 0xde, 0x7a,
    0x2d, 0x44, 0x11, 0x71, 0xe7, 0x08, 0x41, 0xeb, 0xc9, 0x2d, 0x91, 0x43,
    0xd4, 0x07, 0xb5, 0x5d, 0x0d, 0x6a, 0x4f, 0x58, 0xf9, 0x24, 0x7f, 0xdc,
    0xa5, 0x19, 0xb4, 0x69, 0x8f, 0x18, 0x8c, 0x6e, 0x33, 0x48, 0x2d, 0x35,
    0xad, 0x24, 0x5c, 0xe4, 0xde, 0x17, 0xb5, 0x3f, 0xda, 0x23, 0xa5, 0x52,
    0x13, 0x76, 0x2d, 0x5c, 0xf7, 0x7b, 0x43, 0xcb, 0xc5, 0x3a, 0x91, 0x7e,
    0xfc, 0x35, 0xb7, 0x1c, 0x37, 0x59, 0x17, 0x72, 0xdc, 0x07, 0x1b, 0xfa,
    0xa3, 0x19, 0xac, 0x77, 0xfc, 0x2b, 0x95, 0x5e, 0x68, 0x5b, 0x28, 0x7f,
    0xc8, 0x12, 0x7e, 0xfa, 0xba, 0x2a, 0xf6, 0x51, 0xd7, 0x22, 0xb8, 0x70,
    0x6d, 0x70, 0x0d, 0x5a, 0xc7, 0x2d, 0x62, 0xdb, 0xc1, 0x20, 0xaf, 0x40,
    0xd7, 0x33, 0xe1, 0x42, 0x11, 0x64, 0x06, 0x6f, 0xd2, 0x7f, 0x5e, 0xfd,
    0xde, 0x04, 0x93, 0x72, 0xdd, 0x3c, 0x97, 0x44, 0x50, 0x58, 0x2e, 0x57,
    0xd9, 0x0a, 0x7b, 0xcf, 0xb3, 0x69, 0xe8, 0x2a, 0x94, 0x5f, 0xf9, 0x53,
    0x14, 0x78, 0x5f, 0x4e, 0xc8, 0x09, 0x66, 0xc7, 0xb2, 0x43, 0x8e, 0x42,
    0xe0, 0x5f, 0xf9, 0x3b, 0x77, 0x11
};
static const size_t kObfuscatedPublicKeySize = 450;

// Deobfuscate the public key at runtime
static std::string DeobfuscatePublicKey() {
    // Reconstruct the actual PEM key using XOR deobfuscation
    // This is intentionally complex to frustrate static analysis
    volatile size_t key_len = sizeof(kObfuscationKey);
    std::vector<uint8_t> result;
    result.reserve(kObfuscatedPublicKeySize + 1);

    // Deobfuscate byte by byte using XOR
    for (size_t i = 0; i < kObfuscatedPublicKeySize; ++i) {
        volatile uint8_t obf_byte = kObfuscatedPublicKey[i];
        volatile uint8_t key_byte = kObfuscationKey[i % key_len];
        volatile uint8_t plain_byte = obf_byte ^ key_byte;
        result.push_back(static_cast<uint8_t>(plain_byte));
    }

    // Convert to string
    return std::string(result.begin(), result.end());
}

// ============================================================================
// Security Hardening: Runtime Integrity Verification
// ============================================================================

// Structure to hold integrity check state
struct IntegrityState {
    uint64_t code_hash;
    uint64_t func_hash;
    uint64_t signature_valid;
    bool initialized;
};

static volatile IntegrityState g_integrity_state = {0, 0, 0, false};

// FNV-1a hash for better distribution (macOS only)
#if defined(OS_MACOS)
static uint64_t fnv1a_hash(const uint8_t* data, size_t len) {
    uint64_t hash = 0xcbf29ce484222325ULL; // FNV offset basis
    for (size_t i = 0; i < len; i++) {
        hash ^= data[i];
        hash *= 0x100000001b3ULL; // FNV prime
    }
    return hash;
}
#endif

// Hash a function's code bytes
static uint64_t HashFunctionCode(void* func_ptr, size_t estimated_size = 256) {
#if defined(OS_MACOS)
    if (!func_ptr) return 0;

    // Get function info
    Dl_info info;
    if (dladdr(func_ptr, &info) == 0) return 0;

    // Hash the function bytes
    const uint8_t* func_bytes = static_cast<const uint8_t*>(func_ptr);
    return fnv1a_hash(func_bytes, estimated_size);
#else
    return 0;
#endif
}

// Compute checksum of critical code sections
static uint64_t ComputeCodeChecksum() {
#if defined(OS_MACOS)
    // Get the Mach-O header
    Dl_info info;
    if (dladdr((void*)&ComputeCodeChecksum, &info) == 0) {
        return 0;
    }

    const uint8_t* base = static_cast<const uint8_t*>(info.dli_fbase);
    if (!base) return 0;

    // Hash multiple regions of the code segment
    uint64_t hash = 0xcbf29ce484222325ULL;

    // Sample from different offsets in the binary
    // Use prime-number stepping to avoid patterns
    for (size_t i = 0; i < 50000 && i < 0x100000; i += 97) {
        hash ^= base[i];
        hash *= 0x100000001b3ULL;
    }

    // Also hash from the end of the sampled region
    for (size_t i = 50000; i > 40000 && i < 0x100000; i -= 89) {
        hash ^= base[i];
        hash *= 0x100000001b3ULL;
    }

    return hash;
#else
    return 0x87654321ULL;
#endif
}

// Verify macOS code signature at runtime
static bool VerifyCodeSignature() {
#if defined(OS_MACOS)
    // Get path to current executable
    char path[PATH_MAX];
    uint32_t size = sizeof(path);
    if (_NSGetExecutablePath(path, &size) != 0) {
        return false;
    }

    // Create URL for the executable
    CFURLRef url = CFURLCreateFromFileSystemRepresentation(
        kCFAllocatorDefault,
        (const UInt8*)path,
        strlen(path),
        false
    );
    if (!url) return false;

    // Create static code reference
    SecStaticCodeRef staticCode = NULL;
    OSStatus status = SecStaticCodeCreateWithPath(url, kSecCSDefaultFlags, &staticCode);
    CFRelease(url);

    if (status != errSecSuccess || !staticCode) {
        return false;
    }

    // Verify the signature
    // kSecCSCheckAllArchitectures | kSecCSStrictValidate for thorough check
    status = SecStaticCodeCheckValidity(staticCode, kSecCSBasicValidateOnly, NULL);
    CFRelease(staticCode);

    return status == errSecSuccess;
#else
    return true; // Skip on non-macOS
#endif
}

// Check if memory pages have been modified (detect runtime patching)
static bool CheckMemoryProtection() {
#if defined(OS_MACOS)
    // Get info about our code segment
    Dl_info info;
    if (dladdr((void*)&CheckMemoryProtection, &info) == 0) {
        return true; // Can't check, assume OK
    }

    // Check if memory is writable (it shouldn't be for code)
    vm_address_t address = (vm_address_t)info.dli_fbase;
    vm_size_t vmsize;
    vm_region_basic_info_data_64_t vminfo;
    mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;
    memory_object_name_t object;

    kern_return_t kr = vm_region_64(
        mach_task_self(),
        &address,
        &vmsize,
        VM_REGION_BASIC_INFO_64,
        (vm_region_info_t)&vminfo,
        &info_count,
        &object
    );

    if (kr != KERN_SUCCESS) {
        return true; // Can't check, assume OK
    }

    // Code segment should NOT be writable
    if (vminfo.protection & VM_PROT_WRITE) {
        return false; // Someone made code writable - suspicious!
    }

    return true;
#else
    return true;
#endif
}

// Hash critical license validation functions
static uint64_t ComputeFunctionHashes() {
    uint64_t combined = 0;

    // Hash key functions that attackers would want to patch
    combined ^= HashFunctionCode((void*)&ComputeCodeChecksum, 128);
    combined ^= HashFunctionCode((void*)&VerifyCodeSignature, 256);
    combined ^= HashFunctionCode((void*)&CheckMemoryProtection, 256);
    combined ^= HashFunctionCode((void*)&DeobfuscatePublicKey, 128);

    return combined;
}

// Initialize all integrity checks
static void InitializeIntegrityChecks() {
    if (g_integrity_state.initialized) return;

    g_integrity_state.code_hash = ComputeCodeChecksum();
    g_integrity_state.func_hash = ComputeFunctionHashes();
    g_integrity_state.signature_valid = VerifyCodeSignature() ? 1 : 0;
    g_integrity_state.initialized = true;
}

// Main integrity verification function
static bool VerifyCodeNotPatched() {
    if (!g_integrity_state.initialized) {
        InitializeIntegrityChecks();
        return true; // First call, establish baseline
    }

    // Check 1: Code segment hash
    uint64_t current_code_hash = ComputeCodeChecksum();
    if (current_code_hash != g_integrity_state.code_hash) {
        return false; // Code segment was modified
    }

    // Check 2: Critical function hashes
    uint64_t current_func_hash = ComputeFunctionHashes();
    if (current_func_hash != g_integrity_state.func_hash) {
        return false; // Critical functions were patched
    }

    // Check 3: Memory protection (code shouldn't be writable)
    if (!CheckMemoryProtection()) {
        return false; // Memory protection was changed
    }

    // Check 4: Code signature still valid (catches disk modifications)
    // Only check periodically as it's expensive
    static int signature_check_counter = 0;
    if (++signature_check_counter >= 10) {
        signature_check_counter = 0;
        if (!VerifyCodeSignature()) {
            return false; // Binary on disk was modified
        }
    }

    return true;
}

// ============================================================================
// Security Hardening: Anti-Debugging Enhancements
// ============================================================================

// Multiple timing checks to detect debugging (macOS only)
#if defined(OS_MACOS)
static bool TimingBasedDebugCheck() {
    uint64_t start = mach_absolute_time();

    // Do some work that should take a predictable amount of time
    volatile int dummy = 0;
    for (int i = 0; i < 10000; i++) {
        dummy += i;
    }

    uint64_t end = mach_absolute_time();
    uint64_t elapsed = end - start;

    // If under debugger, this will be much slower
    // Normal execution: ~100,000 - 1,000,000 ticks
    // Under debugger: often 10x-100x slower
    static uint64_t baseline = 0;
    if (baseline == 0) {
        baseline = elapsed;
        return false; // First call, establish baseline
    }

    // If current timing is 10x slower than baseline, likely debugging
    if (elapsed > baseline * 10 && baseline > 1000) {
        return true;
    }
    return false;
}
#endif

// Check for common debugging/reversing environment variables (macOS only)
#if defined(OS_MACOS)
static bool CheckDebugEnvironment() {
    const char* suspicious_vars[] = {
        "DYLD_INSERT_LIBRARIES",
        "DYLD_FORCE_FLAT_NAMESPACE",
        "DYLD_LIBRARY_PATH",
        "_MallocStackLogging",
        "MallocScribble",
        "MallocGuardEdges",
        "NSZombieEnabled",
        "LLDB_LAUNCH_FLAG_DISABLE_ASLR",
        nullptr
    };

    for (int i = 0; suspicious_vars[i] != nullptr; i++) {
        if (getenv(suspicious_vars[i]) != nullptr) {
            return true;
        }
    }
    return false;
}
#endif

// Check for debugger using sysctl (harder to bypass than ptrace)
static bool SysctlDebugCheck() {
#if defined(OS_MACOS)
    struct kinfo_proc info;
    size_t info_size = sizeof(info);
    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()};

    // Use volatile to prevent optimization
    volatile int result = sysctl(mib, 4, &info, &info_size, NULL, 0);
    if (result == 0) {
        volatile int flags = info.kp_proc.p_flag;
        if (flags & P_TRACED) {
            return true;
        }
    }
#endif
    return false;
}

// ============================================================================
// Security Hardening: Distributed License Checks with Opaque Predicates
// ============================================================================

// These functions return values that appear data-dependent but are actually
// constant. This confuses static analysis.
static volatile int g_opaque_seed = 42;

__attribute__((noinline))
static bool OpaquePredicateTrue() {
    volatile int x = g_opaque_seed;
    volatile int y = (x * x) % 7;
    volatile int z = (y + 3) % 4;
    return z < 4; // Always true, but not obvious to static analysis
}

__attribute__((noinline))
static bool OpaquePredicateFalse() {
    volatile int x = g_opaque_seed;
    volatile int y = (x * x + x * 3 + 7) % 13;
    return y > 20; // Always false for seed=42, but not obvious
}

// License check with control flow obfuscation
__attribute__((noinline))
static LicenseStatus ObfuscatedLicenseCheck(LicenseManager* mgr);

} // anonymous namespace

// AES key for license data encryption (derived from public key hash)
static std::vector<uint8_t> DeriveAESKey() {
    std::string key_material = DeobfuscatePublicKey();
    return LicenseCrypto::SHA256(std::vector<uint8_t>(key_material.begin(), key_material.end()));
}

// ============================================================================
// License Data Implementation (exception-free)
// ============================================================================

LicenseData::LicenseData()
    : magic(LICENSE_MAGIC)
    , version(LICENSE_VERSION)
    , type(LicenseType::TRIAL)
    , max_seats(1)
    , issue_timestamp(0)
    , expiry_timestamp(0)
    , feature_flags(0)
    , hardware_bound(false)
    , activation_timestamp(0)
    , last_check_timestamp(0)
    , next_check_timestamp(0)
    , grace_period_days(7)
    // Version 2 extended metadata
    , total_activations(0)
    , support_tier(SupportTier::NONE)
    , support_expiry_timestamp(0)
    , maintenance_included(false)
    , maintenance_expiry_timestamp(0) {}

std::vector<uint8_t> LicenseData::Serialize() const {
    std::ostringstream ss;

    ss.write(reinterpret_cast<const char*>(&magic), sizeof(magic));
    ss.write(reinterpret_cast<const char*>(&version), sizeof(version));

    auto writeString = [&ss](const std::string& str) {
        uint32_t len = static_cast<uint32_t>(str.length());
        ss.write(reinterpret_cast<const char*>(&len), sizeof(len));
        ss.write(str.data(), len);
    };

    writeString(license_id);
    writeString(name);
    writeString(organization);
    writeString(email);

    uint8_t type_byte = static_cast<uint8_t>(type);
    ss.write(reinterpret_cast<const char*>(&type_byte), sizeof(type_byte));
    ss.write(reinterpret_cast<const char*>(&max_seats), sizeof(max_seats));
    ss.write(reinterpret_cast<const char*>(&issue_timestamp), sizeof(issue_timestamp));
    ss.write(reinterpret_cast<const char*>(&expiry_timestamp), sizeof(expiry_timestamp));
    ss.write(reinterpret_cast<const char*>(&feature_flags), sizeof(feature_flags));

    uint8_t hw_bound = hardware_bound ? 1 : 0;
    ss.write(reinterpret_cast<const char*>(&hw_bound), sizeof(hw_bound));
    writeString(hardware_fingerprint);
    writeString(custom_data);
    writeString(issuer);
    writeString(notes);

    // Subscription fields (version 1+)
    ss.write(reinterpret_cast<const char*>(&activation_timestamp), sizeof(activation_timestamp));
    ss.write(reinterpret_cast<const char*>(&last_check_timestamp), sizeof(last_check_timestamp));
    ss.write(reinterpret_cast<const char*>(&next_check_timestamp), sizeof(next_check_timestamp));
    ss.write(reinterpret_cast<const char*>(&grace_period_days), sizeof(grace_period_days));

    // === Version 2 Extended Metadata ===
    // Version Control
    writeString(min_browser_version);
    writeString(max_browser_version);

    // Geographic/Compliance
    writeString(allowed_regions);
    writeString(export_control);

    // Usage Tracking
    ss.write(reinterpret_cast<const char*>(&total_activations), sizeof(total_activations));
    writeString(last_device_name);

    // Business Metadata
    writeString(customer_id);
    writeString(plan_id);
    writeString(order_id);
    writeString(invoice_id);
    writeString(reseller_id);

    // Support/SLA
    uint8_t support_tier_byte = static_cast<uint8_t>(support_tier);
    ss.write(reinterpret_cast<const char*>(&support_tier_byte), sizeof(support_tier_byte));
    ss.write(reinterpret_cast<const char*>(&support_expiry_timestamp), sizeof(support_expiry_timestamp));

    // Security
    writeString(revocation_check_url);
    writeString(issued_ip);

    // Maintenance
    uint8_t maint_included = maintenance_included ? 1 : 0;
    ss.write(reinterpret_cast<const char*>(&maint_included), sizeof(maint_included));
    ss.write(reinterpret_cast<const char*>(&maintenance_expiry_timestamp), sizeof(maintenance_expiry_timestamp));

    std::string data = ss.str();
    return std::vector<uint8_t>(data.begin(), data.end());
}

LicenseData LicenseData::Deserialize(const std::vector<uint8_t>& data) {
    LicenseData lic;

    if (data.size() < sizeof(uint32_t) * 2) {
        LOG_ERROR("License", "License data too short");
        return lic;  // Return default (invalid) license
    }

    size_t pos = 0;
    bool error = false;

    auto readUint32 = [&data, &pos, &error]() -> uint32_t {
        if (error || pos + sizeof(uint32_t) > data.size()) {
            error = true;
            return 0;
        }
        uint32_t val;
        std::memcpy(&val, &data[pos], sizeof(uint32_t));
        pos += sizeof(uint32_t);
        return val;
    };

    auto readInt64 = [&data, &pos, &error]() -> int64_t {
        if (error || pos + sizeof(int64_t) > data.size()) {
            error = true;
            return 0;
        }
        int64_t val;
        std::memcpy(&val, &data[pos], sizeof(int64_t));
        pos += sizeof(int64_t);
        return val;
    };

    auto readUint64 = [&data, &pos, &error]() -> uint64_t {
        if (error || pos + sizeof(uint64_t) > data.size()) {
            error = true;
            return 0;
        }
        uint64_t val;
        std::memcpy(&val, &data[pos], sizeof(uint64_t));
        pos += sizeof(uint64_t);
        return val;
    };

    auto readUint8 = [&data, &pos, &error]() -> uint8_t {
        if (error || pos + sizeof(uint8_t) > data.size()) {
            error = true;
            return 0;
        }
        uint8_t val = data[pos];
        pos += sizeof(uint8_t);
        return val;
    };

    auto readString = [&data, &pos, &error, &readUint32]() -> std::string {
        uint32_t len = readUint32();
        if (error || pos + len > data.size()) {
            error = true;
            return "";
        }
        std::string str(reinterpret_cast<const char*>(&data[pos]), len);
        pos += len;
        return str;
    };

    lic.magic = readUint32();
    lic.version = readUint32();

    if (lic.magic != LICENSE_MAGIC) {
        LOG_ERROR("License", "Data format error [M]");
        lic.magic = 0;  // Mark as invalid
        return lic;
    }

    lic.license_id = readString();
    lic.name = readString();
    lic.organization = readString();
    lic.email = readString();

    lic.type = static_cast<LicenseType>(readUint8());
    lic.max_seats = readUint32();
    lic.issue_timestamp = readInt64();
    lic.expiry_timestamp = readInt64();
    lic.feature_flags = readUint64();

    lic.hardware_bound = readUint8() != 0;
    lic.hardware_fingerprint = readString();
    lic.custom_data = readString();
    lic.issuer = readString();
    lic.notes = readString();

    // Subscription fields (version 1+) - read if data available
    if (!error && pos + sizeof(int64_t) * 3 + sizeof(uint32_t) <= data.size()) {
        lic.activation_timestamp = readInt64();
        lic.last_check_timestamp = readInt64();
        lic.next_check_timestamp = readInt64();
        lic.grace_period_days = readUint32();
    }

    // Version 2 extended metadata - read if version >= 2 and data available
    if (!error && lic.version >= 2 && pos < data.size()) {
        // Helper to safely read string only if data available
        auto safeReadString = [&]() -> std::string {
            if (error || pos + sizeof(uint32_t) > data.size()) return "";
            return readString();
        };

        // Version Control
        lic.min_browser_version = safeReadString();
        lic.max_browser_version = safeReadString();

        // Geographic/Compliance
        lic.allowed_regions = safeReadString();
        lic.export_control = safeReadString();

        // Usage Tracking
        if (!error && pos + sizeof(uint32_t) <= data.size()) {
            lic.total_activations = readUint32();
        }
        lic.last_device_name = safeReadString();

        // Business Metadata
        lic.customer_id = safeReadString();
        lic.plan_id = safeReadString();
        lic.order_id = safeReadString();
        lic.invoice_id = safeReadString();
        lic.reseller_id = safeReadString();

        // Support/SLA
        if (!error && pos + sizeof(uint8_t) <= data.size()) {
            lic.support_tier = static_cast<SupportTier>(readUint8());
        }
        if (!error && pos + sizeof(int64_t) <= data.size()) {
            lic.support_expiry_timestamp = readInt64();
        }

        // Security
        lic.revocation_check_url = safeReadString();
        lic.issued_ip = safeReadString();

        // Maintenance
        if (!error && pos + sizeof(uint8_t) <= data.size()) {
            lic.maintenance_included = readUint8() != 0;
        }
        if (!error && pos + sizeof(int64_t) <= data.size()) {
            lic.maintenance_expiry_timestamp = readInt64();
        }
    }

    if (error) {
        LOG_ERROR("License", "Error parsing license data");
        lic.magic = 0;  // Mark as invalid
    }

    return lic;
}

// Version 2 helper methods
bool LicenseData::IsVersionCompatible(const std::string& browser_version) const {
    if (min_browser_version.empty() && max_browser_version.empty()) {
        return true;  // No version restrictions
    }

    // Simple string comparison for semver-like versions
    // Assumes versions are in format "X.Y.Z"
    if (!min_browser_version.empty() && browser_version < min_browser_version) {
        return false;
    }
    if (!max_browser_version.empty() && browser_version > max_browser_version) {
        return false;
    }
    return true;
}

bool LicenseData::IsRegionAllowed(const std::string& region_code) const {
    if (allowed_regions.empty()) {
        return true;  // No region restrictions
    }

    // Check if region_code is in comma-separated list
    size_t pos = 0;
    while (pos < allowed_regions.size()) {
        size_t comma = allowed_regions.find(',', pos);
        std::string region;
        if (comma == std::string::npos) {
            region = allowed_regions.substr(pos);
            pos = allowed_regions.size();
        } else {
            region = allowed_regions.substr(pos, comma - pos);
            pos = comma + 1;
        }
        // Trim whitespace
        while (!region.empty() && region.front() == ' ') region.erase(0, 1);
        while (!region.empty() && region.back() == ' ') region.pop_back();

        if (region == region_code) {
            return true;
        }
    }
    return false;
}

bool LicenseData::IsSupportActive() const {
    if (support_tier == SupportTier::NONE) {
        return false;
    }
    if (support_expiry_timestamp == 0) {
        return true;  // No expiry set, support is active
    }
    auto now = std::chrono::system_clock::now();
    auto epoch = now.time_since_epoch();
    int64_t now_secs = std::chrono::duration_cast<std::chrono::seconds>(epoch).count();
    return now_secs < support_expiry_timestamp;
}

bool LicenseData::IsMaintenanceActive() const {
    if (!maintenance_included) {
        return false;
    }
    if (maintenance_expiry_timestamp == 0) {
        return true;  // No expiry set, maintenance is active
    }
    auto now = std::chrono::system_clock::now();
    auto epoch = now.time_since_epoch();
    int64_t now_secs = std::chrono::duration_cast<std::chrono::seconds>(epoch).count();
    return now_secs < maintenance_expiry_timestamp;
}

// ============================================================================
// Hardware Fingerprint Implementation
// ============================================================================

std::string HardwareFingerprint::Generate() {
    std::ostringstream ss;

    ss << GetMachineId();
    ss << "|";
    ss << GetCPUInfo();
    ss << "|";
    ss << GetMACAddress();
    ss << "|";
    ss << GetDiskSerial();

    return LicenseCrypto::SHA256Hex(ss.str());
}

bool HardwareFingerprint::Verify(const std::string& expected) {
    std::string current = Generate();

    // Allow partial match (some hardware may change)
    if (current.length() >= 32 && expected.length() >= 32) {
        return current.substr(0, 32) == expected.substr(0, 32);
    }

    return current == expected;
}

std::string HardwareFingerprint::GetMachineId() {
#if defined(OS_MACOS)
    io_registry_entry_t ioRegistryRoot = IORegistryEntryFromPath(kIOMainPortDefault, "IOService:/");
    CFStringRef uuidCf = (CFStringRef)IORegistryEntryCreateCFProperty(ioRegistryRoot, CFSTR(kIOPlatformUUIDKey), kCFAllocatorDefault, 0);
    IOObjectRelease(ioRegistryRoot);

    if (uuidCf) {
        char buffer[64];
        CFStringGetCString(uuidCf, buffer, sizeof(buffer), kCFStringEncodingUTF8);
        CFRelease(uuidCf);
        return std::string(buffer);
    }
    return "unknown-mac";
#elif defined(OS_LINUX)
    std::ifstream file("/etc/machine-id");
    if (file.is_open()) {
        std::string id;
        std::getline(file, id);
        return id;
    }

    std::ifstream uuid_file("/sys/class/dmi/id/product_uuid");
    if (uuid_file.is_open()) {
        std::string uuid;
        std::getline(uuid_file, uuid);
        return uuid;
    }
    return "unknown-linux";
#elif defined(OS_WINDOWS)
    HKEY hKey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "SOFTWARE\\Microsoft\\Cryptography",
                     0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        char guid[256];
        DWORD size = sizeof(guid);
        if (RegQueryValueEx(hKey, "MachineGuid", NULL, NULL,
                           (LPBYTE)guid, &size) == ERROR_SUCCESS) {
            RegCloseKey(hKey);
            return std::string(guid);
        }
        RegCloseKey(hKey);
    }
    return "unknown-win";
#else
    return "unknown";
#endif
}

std::string HardwareFingerprint::GetCPUInfo() {
#if defined(OS_MACOS)
    char buffer[256];
    size_t size = sizeof(buffer);
    if (sysctlbyname("machdep.cpu.brand_string", buffer, &size, NULL, 0) == 0) {
        return std::string(buffer);
    }
    return "unknown-cpu";
#elif defined(OS_LINUX)
    std::ifstream cpuinfo("/proc/cpuinfo");
    std::string line;
    while (std::getline(cpuinfo, line)) {
        if (line.find("model name") != std::string::npos) {
            size_t pos = line.find(':');
            if (pos != std::string::npos) {
                return line.substr(pos + 2);
            }
        }
    }
    return "unknown-cpu";
#elif defined(OS_WINDOWS)
    int cpuInfo[4] = {-1};
    char brand[0x40];
    memset(brand, 0, sizeof(brand));

    __cpuid(cpuInfo, 0x80000002);
    memcpy(brand, cpuInfo, sizeof(cpuInfo));
    __cpuid(cpuInfo, 0x80000003);
    memcpy(brand + 16, cpuInfo, sizeof(cpuInfo));
    __cpuid(cpuInfo, 0x80000004);
    memcpy(brand + 32, cpuInfo, sizeof(cpuInfo));

    return std::string(brand);
#else
    return "unknown-cpu";
#endif
}

std::string HardwareFingerprint::GetMACAddress() {
#if defined(OS_MACOS)
    // macOS: Use IOKit to get MAC address
    CFMutableDictionaryRef matchingDict = IOServiceMatching("IOEthernetInterface");
    if (!matchingDict) return "unknown-mac";

    io_iterator_t iter;
    if (IOServiceGetMatchingServices(kIOMainPortDefault, matchingDict, &iter) != KERN_SUCCESS) {
        return "unknown-mac";
    }

    io_object_t service;
    while ((service = IOIteratorNext(iter)) != 0) {
        io_object_t controller;
        if (IORegistryEntryGetParentEntry(service, kIOServicePlane, &controller) == KERN_SUCCESS) {
            CFTypeRef macData = IORegistryEntryCreateCFProperty(controller,
                CFSTR("IOMACAddress"), kCFAllocatorDefault, 0);
            if (macData) {
                if (CFGetTypeID(macData) == CFDataGetTypeID()) {
                    CFDataRef data = (CFDataRef)macData;
                    if (CFDataGetLength(data) == 6) {
                        const UInt8* bytes = CFDataGetBytePtr(data);
                        char macStr[18];
                        snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
                                 bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5]);
                        CFRelease(macData);
                        IOObjectRelease(controller);
                        IOObjectRelease(service);
                        IOObjectRelease(iter);
                        return std::string(macStr);
                    }
                }
                CFRelease(macData);
            }
            IOObjectRelease(controller);
        }
        IOObjectRelease(service);
    }
    IOObjectRelease(iter);
    return "unknown-mac";
#elif defined(OS_LINUX)
    struct ifreq ifr;
    struct ifconf ifc;
    char buf[1024];

    int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
    if (sock == -1) return "unknown-mac";

    ifc.ifc_len = sizeof(buf);
    ifc.ifc_buf = buf;
    if (ioctl(sock, SIOCGIFCONF, &ifc) == -1) {
        close(sock);
        return "unknown-mac";
    }

    struct ifreq* it = ifc.ifc_req;
    const struct ifreq* const end = it + (ifc.ifc_len / sizeof(struct ifreq));

    for (; it != end; ++it) {
        strcpy(ifr.ifr_name, it->ifr_name);
        if (ioctl(sock, SIOCGIFFLAGS, &ifr) == 0) {
            if (!(ifr.ifr_flags & IFF_LOOPBACK)) {
                if (ioctl(sock, SIOCGIFHWADDR, &ifr) == 0) {
                    close(sock);
                    unsigned char* mac = (unsigned char*)ifr.ifr_hwaddr.sa_data;
                    char macStr[18];
                    snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
                             mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
                    return std::string(macStr);
                }
            }
        }
    }
    close(sock);
    return "unknown-mac";
#elif defined(OS_WINDOWS)
    IP_ADAPTER_INFO adapterInfo[16];
    DWORD dwBufLen = sizeof(adapterInfo);

    if (GetAdaptersInfo(adapterInfo, &dwBufLen) == ERROR_SUCCESS) {
        PIP_ADAPTER_INFO pAdapterInfo = adapterInfo;
        char macStr[18];
        snprintf(macStr, sizeof(macStr), "%02x:%02x:%02x:%02x:%02x:%02x",
                 pAdapterInfo->Address[0], pAdapterInfo->Address[1],
                 pAdapterInfo->Address[2], pAdapterInfo->Address[3],
                 pAdapterInfo->Address[4], pAdapterInfo->Address[5]);
        return std::string(macStr);
    }
    return "unknown-mac";
#else
    return "unknown-mac";
#endif
}

std::string HardwareFingerprint::GetDiskSerial() {
#if defined(OS_MACOS)
    io_registry_entry_t ioRegistryRoot = IORegistryEntryFromPath(kIOMainPortDefault, "IOService:/");
    CFStringRef serial = (CFStringRef)IORegistryEntryCreateCFProperty(ioRegistryRoot, CFSTR("IOPlatformSerialNumber"), kCFAllocatorDefault, 0);
    IOObjectRelease(ioRegistryRoot);

    if (serial) {
        char buffer[64];
        CFStringGetCString(serial, buffer, sizeof(buffer), kCFStringEncodingUTF8);
        CFRelease(serial);
        return std::string(buffer);
    }
    return "unknown-disk";
#elif defined(OS_LINUX)
    std::ifstream file("/sys/block/sda/device/serial");
    if (file.is_open()) {
        std::string serial;
        std::getline(file, serial);
        if (!serial.empty()) return serial;
    }

    std::ifstream nvme_file("/sys/class/nvme/nvme0/serial");
    if (nvme_file.is_open()) {
        std::string serial;
        std::getline(nvme_file, serial);
        if (!serial.empty()) return serial;
    }

    return "unknown-disk";
#elif defined(OS_WINDOWS)
    return "unknown-disk";
#else
    return "unknown-disk";
#endif
}

// ============================================================================
// Device Metadata Helpers
// ============================================================================

// Browser version (compile-time constant)
#ifndef OWL_BROWSER_VERSION
#define OWL_BROWSER_VERSION "1.0.0"
#endif

std::string GetBrowserVersion() {
    return OWL_BROWSER_VERSION;
}

std::string GetOSInfo() {
#if defined(OS_MACOS)
    // Get macOS version using sysctl
    char osproductversion[64] = {0};
    size_t size = sizeof(osproductversion);
    if (sysctlbyname("kern.osproductversion", osproductversion, &size, NULL, 0) == 0) {
        return std::string("macOS ") + osproductversion;
    }
    return "macOS (unknown version)";
#elif defined(OS_LINUX)
    struct utsname uts;
    if (uname(&uts) == 0) {
        return std::string(uts.sysname) + " " + uts.release;
    }
    return "Linux (unknown version)";
#elif defined(OS_WINDOWS)
    return "Windows";
#else
    return "Unknown OS";
#endif
}

std::string GetDeviceName() {
#if defined(OS_MACOS)
    char hostname[256] = {0};
    if (gethostname(hostname, sizeof(hostname)) == 0) {
        // Remove .local suffix if present
        std::string name(hostname);
        size_t dotLocal = name.find(".local");
        if (dotLocal != std::string::npos) {
            name = name.substr(0, dotLocal);
        }
        return name;
    }
    return "Unknown Mac";
#elif defined(OS_LINUX)
    struct utsname uts;
    if (uname(&uts) == 0) {
        return std::string(uts.nodename);
    }
    return "Unknown Linux Device";
#elif defined(OS_WINDOWS)
    char hostname[256] = {0};
    DWORD size = sizeof(hostname);
    if (GetComputerNameA(hostname, &size)) {
        return std::string(hostname);
    }
    return "Unknown Windows Device";
#else
    return "Unknown Device";
#endif
}

// Helper to escape strings for JSON
static std::string EscapeJsonString(const std::string& str) {
    std::ostringstream escaped;
    for (char c : str) {
        switch (c) {
            case '"': escaped << "\\\""; break;
            case '\\': escaped << "\\\\"; break;
            case '\b': escaped << "\\b"; break;
            case '\f': escaped << "\\f"; break;
            case '\n': escaped << "\\n"; break;
            case '\r': escaped << "\\r"; break;
            case '\t': escaped << "\\t"; break;
            default:
                if (static_cast<unsigned char>(c) < 0x20) {
                    escaped << "\\u" << std::hex << std::setfill('0') << std::setw(4) << static_cast<int>(c);
                } else {
                    escaped << c;
                }
                break;
        }
    }
    return escaped.str();
}

// ============================================================================
// License File Implementation
// ============================================================================

bool LicenseFile::SaveToFile(const std::string& path) const {
    std::ofstream file(path, std::ios::binary);
    if (!file.is_open()) return false;

    file.write(reinterpret_cast<const char*>(&magic), sizeof(magic));
    file.write(reinterpret_cast<const char*>(&version), sizeof(version));
    file.write(reinterpret_cast<const char*>(&flags), sizeof(flags));

    auto writeVector = [&file](const std::vector<uint8_t>& vec) {
        uint32_t size = static_cast<uint32_t>(vec.size());
        file.write(reinterpret_cast<const char*>(&size), sizeof(size));
        if (size > 0) {
            file.write(reinterpret_cast<const char*>(vec.data()), size);
        }
    };

    writeVector(encrypted_data);
    writeVector(iv);
    writeVector(auth_tag);
    writeVector(signature);

    file.write(reinterpret_cast<const char*>(&checksum), sizeof(checksum));

    return file.good();
}

std::unique_ptr<LicenseFile> LicenseFile::LoadFromFile(const std::string& path) {
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) return nullptr;

    auto lic = std::make_unique<LicenseFile>();

    file.read(reinterpret_cast<char*>(&lic->magic), sizeof(lic->magic));
    file.read(reinterpret_cast<char*>(&lic->version), sizeof(lic->version));
    file.read(reinterpret_cast<char*>(&lic->flags), sizeof(lic->flags));

    if (lic->magic != LICENSE_MAGIC) {
        return nullptr;
    }

    auto readVector = [&file]() -> std::vector<uint8_t> {
        uint32_t size;
        file.read(reinterpret_cast<char*>(&size), sizeof(size));
        if (size > 10 * 1024 * 1024) {  // 10MB sanity check
            return std::vector<uint8_t>();
        }
        std::vector<uint8_t> vec(size);
        if (size > 0) {
            file.read(reinterpret_cast<char*>(vec.data()), size);
        }
        return vec;
    };

    lic->encrypted_data = readVector();
    lic->iv = readVector();
    lic->auth_tag = readVector();
    lic->signature = readVector();

    file.read(reinterpret_cast<char*>(&lic->checksum), sizeof(lic->checksum));

    if (!file.good()) return nullptr;

    return lic;
}

// ============================================================================
// Subscription State Storage Implementation
// ============================================================================

// Salt for state key derivation (obfuscated)
static const uint8_t kStateKeySalt[] = {
    0xA3, 0x7B, 0x2E, 0x91, 0x5C, 0xD4, 0x68, 0xF0,
    0x1B, 0x84, 0xC7, 0x3A, 0xE9, 0x56, 0x0D, 0x72
};

std::string SubscriptionStateStorage::GetStatePath() {
    std::string config_dir;

#if defined(OS_MACOS)
    const char* home = getenv("HOME");
    if (!home) return "";
    config_dir = std::string(home) + "/Library/Application Support/OwlBrowser";
#elif defined(OS_LINUX)
    const char* home = getenv("HOME");
    if (!home) return "";
    const char* xdg_config = getenv("XDG_CONFIG_HOME");
    if (xdg_config) {
        config_dir = std::string(xdg_config) + "/owl-browser";
    } else {
        config_dir = std::string(home) + "/.config/owl-browser";
    }
#elif defined(OS_WINDOWS)
    const char* appdata = getenv("APPDATA");
    if (!appdata) return "";
    config_dir = std::string(appdata) + "\\OwlBrowser";
#else
    return "";
#endif

    struct stat st;
    if (stat(config_dir.c_str(), &st) != 0) {
#if defined(OS_WINDOWS)
        _mkdir(config_dir.c_str());
#else
        mkdir(config_dir.c_str(), 0700);
#endif
    }

    return config_dir + "/.subscription_state";  // Hidden file
}

std::vector<uint8_t> SubscriptionStateStorage::DeriveStateKey() {
    // Derive key from hardware fingerprint + salt
    std::string hw_fp = HardwareFingerprint::Generate();
    std::vector<uint8_t> salt(kStateKeySalt, kStateKeySalt + sizeof(kStateKeySalt));
    return LicenseCrypto::DeriveKey(hw_fp, salt);
}

std::vector<uint8_t> SubscriptionStateStorage::ComputeIntegrityHash(const SubscriptionState& state) {
    std::ostringstream ss;
    ss << state.license_id;
    ss << static_cast<int>(state.status);
    ss << state.activation_timestamp;
    ss << state.last_check_timestamp;
    ss << state.next_check_timestamp;
    ss << state.check_interval_days;
    ss << state.consecutive_failures;
    ss << state.grace_period_days;
    ss << state.server_signature;

    std::string data = ss.str();
    return LicenseCrypto::SHA256(std::vector<uint8_t>(data.begin(), data.end()));
}

bool SubscriptionStateStorage::VerifyIntegrity(const SubscriptionState& state) {
    std::vector<uint8_t> computed = ComputeIntegrityHash(state);
    if (computed.size() != state.integrity_hash.size()) return false;

    // Constant-time comparison
    volatile uint8_t diff = 0;
    for (size_t i = 0; i < computed.size(); i++) {
        diff |= computed[i] ^ state.integrity_hash[i];
    }
    return diff == 0;
}

bool SubscriptionStateStorage::SaveState(const SubscriptionState& state) {
    std::string path = GetStatePath();
    if (path.empty()) return false;

    // Serialize state
    std::ostringstream ss;

    auto writeString = [&ss](const std::string& str) {
        uint32_t len = static_cast<uint32_t>(str.length());
        ss.write(reinterpret_cast<const char*>(&len), sizeof(len));
        ss.write(str.data(), len);
    };

    writeString(state.license_id);
    uint8_t status_byte = static_cast<uint8_t>(state.status);
    ss.write(reinterpret_cast<const char*>(&status_byte), sizeof(status_byte));
    ss.write(reinterpret_cast<const char*>(&state.activation_timestamp), sizeof(state.activation_timestamp));
    ss.write(reinterpret_cast<const char*>(&state.last_check_timestamp), sizeof(state.last_check_timestamp));
    ss.write(reinterpret_cast<const char*>(&state.next_check_timestamp), sizeof(state.next_check_timestamp));
    ss.write(reinterpret_cast<const char*>(&state.check_interval_days), sizeof(state.check_interval_days));
    ss.write(reinterpret_cast<const char*>(&state.consecutive_failures), sizeof(state.consecutive_failures));
    ss.write(reinterpret_cast<const char*>(&state.grace_period_days), sizeof(state.grace_period_days));
    writeString(state.server_signature);

    // Compute integrity hash
    std::vector<uint8_t> integrity = ComputeIntegrityHash(state);
    uint32_t hash_len = static_cast<uint32_t>(integrity.size());
    ss.write(reinterpret_cast<const char*>(&hash_len), sizeof(hash_len));
    ss.write(reinterpret_cast<const char*>(integrity.data()), integrity.size());

    std::string serialized = ss.str();
    std::vector<uint8_t> plaintext(serialized.begin(), serialized.end());

    // Encrypt with hardware-derived key
    std::vector<uint8_t> key = DeriveStateKey();
    std::vector<uint8_t> ciphertext, iv, tag;
    if (!LicenseCrypto::Encrypt(plaintext, key, ciphertext, iv, tag)) {
        return false;
    }

    // Write to file
    std::ofstream file(path, std::ios::binary);
    if (!file.is_open()) return false;

    // Write magic
    uint32_t magic = 0x53554253; // "SUBS"
    file.write(reinterpret_cast<const char*>(&magic), sizeof(magic));

    // Write IV
    uint32_t iv_len = static_cast<uint32_t>(iv.size());
    file.write(reinterpret_cast<const char*>(&iv_len), sizeof(iv_len));
    file.write(reinterpret_cast<const char*>(iv.data()), iv.size());

    // Write tag
    uint32_t tag_len = static_cast<uint32_t>(tag.size());
    file.write(reinterpret_cast<const char*>(&tag_len), sizeof(tag_len));
    file.write(reinterpret_cast<const char*>(tag.data()), tag.size());

    // Write ciphertext
    uint32_t ct_len = static_cast<uint32_t>(ciphertext.size());
    file.write(reinterpret_cast<const char*>(&ct_len), sizeof(ct_len));
    file.write(reinterpret_cast<const char*>(ciphertext.data()), ciphertext.size());

    return file.good();
}

std::unique_ptr<SubscriptionStateStorage::SubscriptionState> SubscriptionStateStorage::LoadState() {
    std::string path = GetStatePath();
    if (path.empty()) return nullptr;

    std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) return nullptr;

    // Read magic
    uint32_t magic;
    file.read(reinterpret_cast<char*>(&magic), sizeof(magic));
    if (magic != 0x53554253) return nullptr;  // "SUBS"

    // Read IV
    uint32_t iv_len;
    file.read(reinterpret_cast<char*>(&iv_len), sizeof(iv_len));
    if (iv_len > 256) return nullptr;
    std::vector<uint8_t> iv(iv_len);
    file.read(reinterpret_cast<char*>(iv.data()), iv_len);

    // Read tag
    uint32_t tag_len;
    file.read(reinterpret_cast<char*>(&tag_len), sizeof(tag_len));
    if (tag_len > 256) return nullptr;
    std::vector<uint8_t> tag(tag_len);
    file.read(reinterpret_cast<char*>(tag.data()), tag_len);

    // Read ciphertext
    uint32_t ct_len;
    file.read(reinterpret_cast<char*>(&ct_len), sizeof(ct_len));
    if (ct_len > 10 * 1024) return nullptr;  // 10KB sanity check
    std::vector<uint8_t> ciphertext(ct_len);
    file.read(reinterpret_cast<char*>(ciphertext.data()), ct_len);

    if (!file.good()) return nullptr;

    // Decrypt
    std::vector<uint8_t> key = DeriveStateKey();
    std::vector<uint8_t> plaintext;
    if (!LicenseCrypto::Decrypt(ciphertext, key, iv, tag, plaintext)) {
        return nullptr;  // Decryption failed - tampered or wrong hardware
    }

    // Deserialize
    auto state = std::make_unique<SubscriptionState>();
    size_t pos = 0;

    auto readUint32 = [&plaintext, &pos]() -> uint32_t {
        if (pos + sizeof(uint32_t) > plaintext.size()) return 0;
        uint32_t val;
        std::memcpy(&val, &plaintext[pos], sizeof(uint32_t));
        pos += sizeof(uint32_t);
        return val;
    };

    auto readInt64 = [&plaintext, &pos]() -> int64_t {
        if (pos + sizeof(int64_t) > plaintext.size()) return 0;
        int64_t val;
        std::memcpy(&val, &plaintext[pos], sizeof(int64_t));
        pos += sizeof(int64_t);
        return val;
    };

    auto readString = [&plaintext, &pos, &readUint32]() -> std::string {
        uint32_t len = readUint32();
        if (pos + len > plaintext.size()) return "";
        std::string str(reinterpret_cast<const char*>(&plaintext[pos]), len);
        pos += len;
        return str;
    };

    state->license_id = readString();
    state->status = static_cast<SubscriptionStatus>(plaintext[pos++]);
    state->activation_timestamp = readInt64();
    state->last_check_timestamp = readInt64();
    state->next_check_timestamp = readInt64();
    state->check_interval_days = readUint32();
    state->consecutive_failures = readUint32();
    state->grace_period_days = readUint32();
    state->server_signature = readString();

    // Read integrity hash
    uint32_t hash_len = readUint32();
    if (pos + hash_len > plaintext.size()) return nullptr;
    state->integrity_hash.assign(plaintext.begin() + pos, plaintext.begin() + pos + hash_len);

    // Verify integrity
    if (!VerifyIntegrity(*state)) {
        return nullptr;  // State was tampered with
    }

    return state;
}

bool SubscriptionStateStorage::DeleteState() {
    std::string path = GetStatePath();
    if (path.empty()) return false;
    return std::remove(path.c_str()) == 0;
}

// ============================================================================
// License Manager Implementation
// ============================================================================

LicenseManager* LicenseManager::instance_ = nullptr;
std::mutex LicenseManager::instance_mutex_;

struct LicenseManager::LicenseState {
    std::atomic<bool> valid{false};
    std::atomic<LicenseStatus> status{LicenseStatus::NOT_FOUND};
    std::unique_ptr<LicenseData> data;
    std::string license_path;
    int64_t last_check_time{0};
    int64_t validation_count{0};

    std::vector<uint8_t> encrypted_valid_token;

    // Subscription state (cached from SubscriptionStateStorage)
    std::atomic<SubscriptionStatus> subscription_status{SubscriptionStatus::UNKNOWN};
    int64_t subscription_activation_time{0};
    int64_t subscription_next_check{0};
    uint32_t subscription_consecutive_failures{0};

    // Daily license check state (for ALL license types)
    int64_t daily_check_last_timestamp{0};
    uint32_t daily_check_consecutive_failures{0};
    static constexpr int64_t DAILY_CHECK_INTERVAL = 86400;  // 24 hours in seconds
    static constexpr uint32_t DAILY_CHECK_GRACE_DAYS = 3;   // 3 days grace period if server unreachable

    std::mutex state_mutex;

    bool IsReallyValid() const {
        if (!valid.load()) return false;
        if (status.load() != LicenseStatus::VALID) return false;
        if (!data) return false;
        return !encrypted_valid_token.empty();
    }

    bool IsSubscriptionValid() const {
        if (!data) return false;
        if (data->type != LicenseType::SUBSCRIPTION) return true;  // Non-subscription always valid
        SubscriptionStatus sub_status = subscription_status.load();
        return sub_status == SubscriptionStatus::ACTIVE ||
               sub_status == SubscriptionStatus::SERVER_ERROR;  // Grace period
    }
};

LicenseManager::LicenseManager()
    : state_(std::make_unique<LicenseState>()) {

    std::string default_path = GetDefaultLicensePath();
    if (!default_path.empty()) {
        auto file = LicenseFile::LoadFromFile(default_path);
        if (file) {
            Validate();
        }
    }
}

LicenseManager::~LicenseManager() = default;

LicenseManager* LicenseManager::GetInstance() {
    std::lock_guard<std::mutex> lock(instance_mutex_);
    if (instance_ == nullptr) {
        instance_ = new LicenseManager();
    }
    return instance_;
}

std::string LicenseManager::GetDefaultLicensePath() {
    std::string config_dir;

#if defined(OS_MACOS)
    const char* home = getenv("HOME");
    if (!home) return "";
    config_dir = std::string(home) + "/Library/Application Support/OwlBrowser";
#elif defined(OS_LINUX)
    const char* home = getenv("HOME");
    if (!home) return "";
    const char* xdg_config = getenv("XDG_CONFIG_HOME");
    if (xdg_config) {
        config_dir = std::string(xdg_config) + "/owl-browser";
    } else {
        config_dir = std::string(home) + "/.config/owl-browser";
    }
#elif defined(OS_WINDOWS)
    const char* appdata = getenv("APPDATA");
    if (!appdata) return "";
    config_dir = std::string(appdata) + "\\OwlBrowser";
#else
    return "";
#endif

    struct stat st;
    if (stat(config_dir.c_str(), &st) != 0) {
#if defined(OS_WINDOWS)
        _mkdir(config_dir.c_str());
#else
        mkdir(config_dir.c_str(), 0700);
#endif
    }

    return config_dir + "/license.olic";
}

LicenseStatus LicenseManager::AddLicense(const std::string& license_path) {
    std::lock_guard<std::mutex> lock(state_->state_mutex);

    auto file = LicenseFile::LoadFromFile(license_path);
    if (!file) {
        state_->status = LicenseStatus::CORRUPTED;
        state_->valid = false;
        LOG_ERROR("License", "Load failed: " + license_path);
        return LicenseStatus::CORRUPTED;
    }

    if (!VerifySignature(*file)) {
        state_->status = LicenseStatus::INVALID_SIGNATURE;
        state_->valid = false;
        LOG_ERROR("License", "Verification failed [S]");
        return LicenseStatus::INVALID_SIGNATURE;
    }

    LicenseData data;
    if (!DecryptLicenseData(*file, data)) {
        state_->status = LicenseStatus::CORRUPTED;
        state_->valid = false;
        LOG_ERROR("License", "Processing failed [D]");
        return LicenseStatus::CORRUPTED;
    }

    if (!ValidateExpiry(data)) {
        state_->status = LicenseStatus::EXPIRED;
        state_->valid = false;
        LOG_WARN("License", "Time constraint [E]");
        return LicenseStatus::EXPIRED;
    }

    if (!ValidateHardware(data)) {
        state_->status = LicenseStatus::HARDWARE_MISMATCH;
        state_->valid = false;
        LOG_ERROR("License", "Environment mismatch [H]");
        ReportTamperingToServer(LicenseStatus::HARDWARE_MISMATCH, "Hardware mismatch during license addition");
        return LicenseStatus::HARDWARE_MISMATCH;
    }

    if (CheckClockManipulation()) {
        state_->status = LicenseStatus::CLOCK_MANIPULATED;
        state_->valid = false;
        LOG_ERROR("License", "Time anomaly [C]");
        ReportTamperingToServer(LicenseStatus::CLOCK_MANIPULATED, "System clock manipulation detected during license addition");
        return LicenseStatus::CLOCK_MANIPULATED;
    }

    // Activate license with server for ALL license types
    // This tracks seat usage and enforces max_seats limit
    int seat_count = 0;
    int max_seats = data.max_seats;

    // Temporarily unlock mutex for server call
    state_->state_mutex.unlock();
    bool activation_success = ActivateLicenseWithServer(data.license_id, seat_count, max_seats);
    state_->state_mutex.lock();

    if (!activation_success) {
        // Check if it's a seat exceeded error (max_seats reached)
        if (seat_count >= max_seats && max_seats > 0) {
            state_->status = LicenseStatus::SEAT_EXCEEDED;
            state_->valid = false;
            LOG_ERROR("License", "Maximum seats exceeded (" +
                     std::to_string(seat_count) + "/" + std::to_string(max_seats) + ")");
            return LicenseStatus::SEAT_EXCEEDED;
        }

        // For non-subscription licenses, we may allow offline activation
        // if no server is configured (graceful degradation)
        std::string server_url = GetLicenseServerUrl();
        if (server_url.empty()) {
            LOG_WARN("License", "No license server configured, allowing offline activation");
        } else {
            state_->status = LicenseStatus::SUBSCRIPTION_CHECK_FAILED;
            state_->valid = false;
            LOG_ERROR("License", "License activation with server failed");
            return LicenseStatus::SUBSCRIPTION_CHECK_FAILED;
        }
    }

    std::string default_path = GetDefaultLicensePath();
    if (!default_path.empty() && license_path != default_path) {
        std::ifstream src(license_path, std::ios::binary);
        std::ofstream dst(default_path, std::ios::binary);
        dst << src.rdbuf();
    }

    state_->data = std::make_unique<LicenseData>(data);
    state_->license_path = default_path.empty() ? license_path : default_path;
    state_->status = LicenseStatus::VALID;
    state_->valid = true;
    state_->last_check_time = GetSecureTimestamp();
    state_->encrypted_valid_token = LicenseCrypto::RandomBytes(32);

    // Obfuscated log message (reconstructed at runtime)
    std::string msg;
    msg.reserve(64);
    const char m[] = {0x4c^0x20, 0x69^0x20, 0x63^0x20, 0x65^0x20, 0x6e^0x20, 0x73^0x20, 0x65^0x20, 0x20^0x20,
                      0x4f^0x20, 0x4b^0x20, 0x00}; // "License OK"
    for (int i = 0; m[i]; i++) msg += (char)(m[i] ^ 0x20);
    LOG_DEBUG("License", msg + ": " + data.name);

    return LicenseStatus::VALID;
}

LicenseStatus LicenseManager::RemoveLicense() {
    std::lock_guard<std::mutex> lock(state_->state_mutex);

    std::string path = GetDefaultLicensePath();
    if (!path.empty()) {
        std::remove(path.c_str());
    }

    state_->data.reset();
    state_->license_path.clear();
    state_->status = LicenseStatus::NOT_FOUND;
    state_->valid = false;
    state_->encrypted_valid_token.clear();

    LOG_DEBUG("License", "State cleared");
    return LicenseStatus::NOT_FOUND;
}

// ============================================================================
// Security Hardening: Obfuscated License Check Implementation
// ============================================================================
// This function is defined in the anonymous namespace to help prevent
// easy identification in disassembly. It's marked noinline to prevent
// the compiler from inlining and exposing the check logic.

namespace {

__attribute__((noinline))
static LicenseStatus ObfuscatedLicenseCheck(LicenseManager* mgr) {
    // Use opaque predicates to obfuscate control flow
    volatile int check_var = 0;

    // Multiple redundant checks that appear data-dependent
    if (OpaquePredicateTrue()) {
        check_var += 1;
    }

    // This appears to be a meaningful check but is always false
    if (OpaquePredicateFalse()) {
        return LicenseStatus::TAMPERED;
    }

    // Verify code integrity
    if (!VerifyCodeNotPatched()) {
        return LicenseStatus::TAMPERED;
    }

    // Add some junk calculations to confuse analysis
    volatile uint32_t junk = 0xDEADBEEF;
    for (int i = 0; i < 3; i++) {
        junk = (junk << 13) ^ (junk >> 17) ^ (junk << 5);
    }

    // Only proceed if opaque predicate allows (always will)
    if (check_var > 0 && OpaquePredicateTrue()) {
        return LicenseStatus::VALID;
    }

    // Dead code - never reached but makes analysis harder
    return LicenseStatus::INTERNAL_ERROR;
}

} // anonymous namespace

LicenseStatus LicenseManager::Validate() {
    std::lock_guard<std::mutex> lock(state_->state_mutex);

    // Security check 1: Debugger detection (multiple layers)
    if (DetectDebugger()) {
        state_->status = LicenseStatus::DEBUG_DETECTED;
        state_->valid = false;
        ReportTamperingToServer(LicenseStatus::DEBUG_DETECTED, "Debugger attached during validation");
        return LicenseStatus::DEBUG_DETECTED;
    }

    // Security check 2: Code integrity (detect patching)
    if (!VerifyCodeIntegrity()) {
        state_->status = LicenseStatus::TAMPERED;
        state_->valid = false;
        ReportTamperingToServer(LicenseStatus::TAMPERED, "Code integrity check failed");
        return LicenseStatus::TAMPERED;
    }

    // Opaque predicate - confuses static analysis
    if (OpaquePredicateFalse()) {
        state_->status = LicenseStatus::INTERNAL_ERROR;
        return LicenseStatus::INTERNAL_ERROR;
    }

    std::string path = GetDefaultLicensePath();
    auto file = LicenseFile::LoadFromFile(path);
    if (!file) {
        state_->status = LicenseStatus::NOT_FOUND;
        state_->valid = false;
        return LicenseStatus::NOT_FOUND;
    }

    // Additional integrity check between operations
    if (!OpaquePredicateTrue()) {
        state_->status = LicenseStatus::TAMPERED;
        return LicenseStatus::TAMPERED;
    }

    if (!VerifySignature(*file)) {
        state_->status = LicenseStatus::INVALID_SIGNATURE;
        state_->valid = false;
        ReportTamperingToServer(LicenseStatus::INVALID_SIGNATURE, "License signature verification failed");
        return LicenseStatus::INVALID_SIGNATURE;
    }

    LicenseData data;
    if (!DecryptLicenseData(*file, data)) {
        state_->status = LicenseStatus::CORRUPTED;
        state_->valid = false;
        ReportTamperingToServer(LicenseStatus::CORRUPTED, "License data decryption failed - possible tampering");
        return LicenseStatus::CORRUPTED;
    }

    // Re-check debugger mid-validation (catches attach during validation)
    if (SysctlDebugCheck()) {
        state_->status = LicenseStatus::DEBUG_DETECTED;
        state_->valid = false;
        ReportTamperingToServer(LicenseStatus::DEBUG_DETECTED, "Debugger attached mid-validation");
        return LicenseStatus::DEBUG_DETECTED;
    }

    if (!ValidateExpiry(data)) {
        state_->status = LicenseStatus::EXPIRED;
        state_->valid = false;
        return LicenseStatus::EXPIRED;
    }

    if (!ValidateHardware(data)) {
        state_->status = LicenseStatus::HARDWARE_MISMATCH;
        state_->valid = false;
        ReportTamperingToServer(LicenseStatus::HARDWARE_MISMATCH, "License used on different hardware than bound");
        return LicenseStatus::HARDWARE_MISMATCH;
    }

    // Final obfuscated check
    LicenseStatus obf_result = ObfuscatedLicenseCheck(this);
    if (obf_result != LicenseStatus::VALID) {
        state_->status = obf_result;
        state_->valid = false;
        ReportTamperingToServer(obf_result, "Obfuscated integrity check failed");
        return obf_result;
    }

    state_->data = std::make_unique<LicenseData>(data);
    state_->license_path = path;

    // For subscription licenses, validate with server
    if (data.type == LicenseType::SUBSCRIPTION) {
        // Need to unlock mutex for subscription validation (it may call server)
        state_->state_mutex.unlock();
        bool subscription_valid = ValidateSubscription(data);
        state_->state_mutex.lock();

        if (!subscription_valid) {
            SubscriptionStatus sub_status = state_->subscription_status.load();
            if (sub_status == SubscriptionStatus::INACTIVE) {
                state_->status = LicenseStatus::SUBSCRIPTION_INACTIVE;
                state_->valid = false;
                LOG_WARN("License", "Subscription is inactive");
                return LicenseStatus::SUBSCRIPTION_INACTIVE;
            } else {
                state_->status = LicenseStatus::SUBSCRIPTION_CHECK_FAILED;
                state_->valid = false;
                LOG_ERROR("License", "Subscription validation failed");
                return LicenseStatus::SUBSCRIPTION_CHECK_FAILED;
            }
        }
    }

    // Daily license validation check (applies to ALL license types)
    // This ensures canceled licenses are detected within 24 hours (with 3-day grace period)
    if (IsDailyCheckDue()) {
        // Need to unlock mutex for daily check (it may call server)
        state_->state_mutex.unlock();
        bool daily_check_passed = PerformDailyLicenseCheck(data);
        state_->state_mutex.lock();

        if (!daily_check_passed) {
            state_->status = LicenseStatus::SUBSCRIPTION_CHECK_FAILED;
            state_->valid = false;
            LOG_ERROR("License", "Daily license validation failed - license may be revoked");
            return LicenseStatus::SUBSCRIPTION_CHECK_FAILED;
        }
    }

    state_->status = LicenseStatus::VALID;
    state_->valid = true;
    state_->last_check_time = GetSecureTimestamp();
    state_->validation_count++;

    // Generate cryptographic token that proves validation occurred
    // This is checked by IsReallyValid() to prevent simple bool patching
    state_->encrypted_valid_token = LicenseCrypto::RandomBytes(32);

    return LicenseStatus::VALID;
}

bool LicenseManager::IsValid() const {
    return state_->IsReallyValid();
}

LicenseStatus LicenseManager::GetStatus() const {
    return state_->status.load();
}

std::string LicenseManager::GetStatusMessage() const {
    return LicenseStatusToString(state_->status.load());
}

const LicenseData* LicenseManager::GetLicenseData() const {
    std::lock_guard<std::mutex> lock(state_->state_mutex);
    return state_->data.get();
}

std::string LicenseManager::GetLicenseInfo() const {
    std::lock_guard<std::mutex> lock(state_->state_mutex);

    std::ostringstream json;
    json << "{";
    json << "\"status\":\"" << LicenseStatusToString(state_->status) << "\"";
    json << ",\"valid\":" << (state_->IsReallyValid() ? "true" : "false");

    if (state_->data) {
        const auto& d = *state_->data;
        json << ",\"license_id\":\"" << d.license_id << "\"";
        json << ",\"name\":\"" << d.name << "\"";
        json << ",\"organization\":\"" << d.organization << "\"";
        json << ",\"email\":\"" << d.email << "\"";
        json << ",\"type\":" << static_cast<int>(d.type);
        json << ",\"max_seats\":" << d.max_seats;
        json << ",\"issue_date\":" << d.issue_timestamp;
        json << ",\"expiry_date\":" << d.expiry_timestamp;
        json << ",\"hardware_bound\":" << (d.hardware_bound ? "true" : "false");
    }

    json << "}";
    return json.str();
}

std::string LicenseManager::GetLicensePath() const {
    std::lock_guard<std::mutex> lock(state_->state_mutex);
    return state_->license_path;
}

bool LicenseManager::VerifyIntegrity() {
    if (!state_->IsReallyValid()) {
        return false;
    }

    int64_t now = GetSecureTimestamp();
    if (now - state_->last_check_time > 300) {
        Validate();
    }

    return state_->IsReallyValid();
}

bool LicenseManager::DetectDebugger() {
#if defined(OS_MACOS)
    // Multiple layers of debugger detection

    // Layer 1: Classic ptrace check (can be bypassed, but raises the bar)
    // Note: Only call once per process, subsequent calls fail
    static bool ptrace_called = false;
    if (!ptrace_called) {
        ptrace_called = true;
        if (ptrace(PT_DENY_ATTACH, 0, 0, 0) == -1) {
            // ptrace failed - might already be attached
            // Don't return true immediately as this could be a false positive
        }
    }

    // Layer 2: Check for debugging environment variables
    if (CheckDebugEnvironment()) {
        return true;
    }

    // Layer 3: sysctl-based P_TRACED check (harder to bypass than ptrace)
    if (SysctlDebugCheck()) {
        return true;
    }

    // Layer 4: Timing-based check (detects single-stepping)
    if (TimingBasedDebugCheck()) {
        return true;
    }

    // Layer 5: Check if code has been patched (detects binary modification)
    if (!VerifyCodeNotPatched()) {
        return true;
    }

#elif defined(OS_LINUX)
    // Linux: Check TracerPid - this is the most reliable method
    std::ifstream status("/proc/self/status");
    std::string line;
    while (std::getline(status, line)) {
        if (line.find("TracerPid:") == 0) {
            int tracer_pid = std::stoi(line.substr(10));
            if (tracer_pid != 0) {
                return true;
            }
            break;
        }
    }

    // Note: We intentionally do NOT use ptrace(PTRACE_TRACEME) here because:
    // 1. PTRACE_TRACEME can only be called once per process
    // 2. CEF or other components may have already called it
    // 3. TracerPid check above is sufficient and more reliable

#elif defined(OS_WINDOWS)
    if (IsDebuggerPresent()) {
        return true;
    }

    BOOL isRemoteDebuggerPresent = FALSE;
    CheckRemoteDebuggerPresent(GetCurrentProcess(), &isRemoteDebuggerPresent);
    if (isRemoteDebuggerPresent) {
        return true;
    }

    // Check for hardware breakpoints
    CONTEXT ctx;
    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
    if (GetThreadContext(GetCurrentThread(), &ctx)) {
        if (ctx.Dr0 || ctx.Dr1 || ctx.Dr2 || ctx.Dr3) {
            return true;
        }
    }
#endif

    return false;
}

bool LicenseManager::VerifyCodeIntegrity() {
    // Initialize integrity checks on first call
    InitializeIntegrityChecks();

    // Verify the code hasn't been patched (multi-layer check)
    // This checks: code hash, function hashes, memory protection, code signature
    if (!VerifyCodeNotPatched()) {
        return false;
    }

    // Additional integrity check: verify license functions exist
    // This catches cases where functions are NOP'd out
    volatile auto validate_fn = &LicenseManager::Validate;
    volatile auto integrity_fn = &LicenseManager::VerifyIntegrity;

    // Opaque predicate - always true but confuses static analysis
    if (OpaquePredicateFalse()) {
        return false; // Dead code, but makes control flow harder to analyze
    }

    return OpaquePredicateTrue() && validate_fn != nullptr && integrity_fn != nullptr;
}

bool LicenseManager::VerifySignature(const LicenseFile& file) {
    std::vector<uint8_t> public_key = GetPublicKey();
    return LicenseCrypto::VerifyRSA(file.encrypted_data, file.signature, public_key);
}

bool LicenseManager::DecryptLicenseData(const LicenseFile& file, LicenseData& data) {
    std::vector<uint8_t> key = DeriveAESKey();
    std::vector<uint8_t> plaintext;

    if (!LicenseCrypto::Decrypt(file.encrypted_data, key, file.iv, file.auth_tag, plaintext)) {
        return false;
    }

    data = LicenseData::Deserialize(plaintext);
    return data.magic == LICENSE_MAGIC;
}

bool LicenseManager::ValidateExpiry(const LicenseData& data) {
    if (data.expiry_timestamp == 0) {
        return true;
    }

    int64_t now = GetSecureTimestamp();
    return now < data.expiry_timestamp;
}

bool LicenseManager::ValidateHardware(const LicenseData& data) {
    if (!data.hardware_bound) {
        return true;
    }

    return HardwareFingerprint::Verify(data.hardware_fingerprint);
}

bool LicenseManager::ValidateSeats(const LicenseData& data) {
    (void)data;
    return true;
}

int64_t LicenseManager::GetSecureTimestamp() const {
    auto now = std::chrono::system_clock::now();
    auto epoch = now.time_since_epoch();
    return std::chrono::duration_cast<std::chrono::seconds>(epoch).count();
}

bool LicenseManager::CheckClockManipulation() {
    int64_t now = GetSecureTimestamp();

    if (state_->last_check_time > 0 && now < state_->last_check_time - 86400) {
        return true;
    }

    return false;
}

std::vector<uint8_t> LicenseManager::GetPublicKey() {
    // Use deobfuscated key to prevent easy extraction via strings
    std::string pem_key = DeobfuscatePublicKey();
    return std::vector<uint8_t>(pem_key.begin(), pem_key.end());
}

// ============================================================================
// Crypto Implementation
// ============================================================================

#if defined(OS_MACOS)

bool LicenseCrypto::VerifyRSA(const std::vector<uint8_t>& data,
                               const std::vector<uint8_t>& signature,
                               const std::vector<uint8_t>& public_key) {
    CFDataRef keyData = CFDataCreate(kCFAllocatorDefault, public_key.data(), public_key.size());
    if (!keyData) return false;

    SecExternalFormat format = kSecFormatPEMSequence;
    SecExternalItemType itemType = kSecItemTypePublicKey;
    CFArrayRef items = nullptr;

    OSStatus status = SecItemImport(keyData, NULL, &format, &itemType,
                                    0, NULL, NULL, &items);
    CFRelease(keyData);

    if (status != errSecSuccess || !items || CFArrayGetCount(items) == 0) {
        if (items) CFRelease(items);
        return false;
    }

    SecKeyRef publicKey = (SecKeyRef)CFArrayGetValueAtIndex(items, 0);

    std::vector<uint8_t> hash = SHA256(data);

    CFDataRef hashData = CFDataCreate(kCFAllocatorDefault, hash.data(), hash.size());
    CFDataRef sigData = CFDataCreate(kCFAllocatorDefault, signature.data(), signature.size());

    CFErrorRef error = nullptr;
    bool result = SecKeyVerifySignature(publicKey,
                                        kSecKeyAlgorithmRSASignatureDigestPKCS1v15SHA256,
                                        hashData, sigData, &error);

    if (error) CFRelease(error);
    CFRelease(hashData);
    CFRelease(sigData);
    CFRelease(items);

    return result;
}

bool LicenseCrypto::SignRSA(const std::vector<uint8_t>& data,
                             const std::vector<uint8_t>& private_key,
                             std::vector<uint8_t>& signature) {
    (void)data;
    (void)private_key;
    (void)signature;
    return false;  // Not implemented in browser - only in generator
}

bool LicenseCrypto::Encrypt(const std::vector<uint8_t>& plaintext,
                             const std::vector<uint8_t>& key,
                             std::vector<uint8_t>& ciphertext,
                             std::vector<uint8_t>& iv,
                             std::vector<uint8_t>& tag) {
    if (key.size() != 32) return false;

    iv = RandomBytes(16);  // AES block size

    // Calculate output size with PKCS7 padding
    size_t padded_size = ((plaintext.size() / kCCBlockSizeAES128) + 1) * kCCBlockSizeAES128;
    ciphertext.resize(padded_size);

    size_t outLen = 0;
    CCCryptorStatus status = CCCrypt(
        kCCEncrypt,
        kCCAlgorithmAES,
        kCCOptionPKCS7Padding,
        key.data(), key.size(),
        iv.data(),
        plaintext.data(), plaintext.size(),
        ciphertext.data(), ciphertext.size(),
        &outLen
    );

    if (status != kCCSuccess) return false;

    ciphertext.resize(outLen);

    // Generate HMAC over IV + ciphertext as authentication tag (SHA256 = 32 bytes)
    tag.resize(CC_SHA256_DIGEST_LENGTH);
    std::vector<uint8_t> hmac_data;
    hmac_data.insert(hmac_data.end(), iv.begin(), iv.end());
    hmac_data.insert(hmac_data.end(), ciphertext.begin(), ciphertext.end());
    CCHmac(kCCHmacAlgSHA256, key.data(), key.size(),
           hmac_data.data(), hmac_data.size(),
           tag.data());

    return true;
}

bool LicenseCrypto::Decrypt(const std::vector<uint8_t>& ciphertext,
                             const std::vector<uint8_t>& key,
                             const std::vector<uint8_t>& iv,
                             const std::vector<uint8_t>& tag,
                             std::vector<uint8_t>& plaintext) {
    if (key.size() != 32 || iv.size() != 16 || tag.size() != CC_SHA256_DIGEST_LENGTH) return false;

    // Verify HMAC first (computed over IV + ciphertext)
    std::vector<uint8_t> computed_tag(CC_SHA256_DIGEST_LENGTH);
    std::vector<uint8_t> hmac_data;
    hmac_data.insert(hmac_data.end(), iv.begin(), iv.end());
    hmac_data.insert(hmac_data.end(), ciphertext.begin(), ciphertext.end());
    CCHmac(kCCHmacAlgSHA256, key.data(), key.size(),
           hmac_data.data(), hmac_data.size(),
           computed_tag.data());

    // Constant-time comparison of full tag
    volatile uint8_t diff = 0;
    for (size_t i = 0; i < CC_SHA256_DIGEST_LENGTH; i++) {
        diff |= computed_tag[i] ^ tag[i];
    }
    if (diff != 0) return false;

    plaintext.resize(ciphertext.size());

    size_t outLen = 0;
    CCCryptorStatus status = CCCrypt(
        kCCDecrypt,
        kCCAlgorithmAES,
        kCCOptionPKCS7Padding,
        key.data(), key.size(),
        iv.data(),
        ciphertext.data(), ciphertext.size(),
        plaintext.data(), plaintext.size(),
        &outLen
    );

    if (status != kCCSuccess) return false;

    plaintext.resize(outLen);
    return true;
}

std::vector<uint8_t> LicenseCrypto::SHA256(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> hash(CC_SHA256_DIGEST_LENGTH);
    CC_SHA256(data.data(), static_cast<CC_LONG>(data.size()), hash.data());
    return hash;
}

std::vector<uint8_t> LicenseCrypto::RandomBytes(size_t length) {
    std::vector<uint8_t> bytes(length);
    CCRandomGenerateBytes(bytes.data(), length);
    return bytes;
}

#elif defined(OS_LINUX)

bool LicenseCrypto::VerifyRSA(const std::vector<uint8_t>& data,
                               const std::vector<uint8_t>& signature,
                               const std::vector<uint8_t>& public_key) {
    BIO* bio = BIO_new_mem_buf(public_key.data(), static_cast<int>(public_key.size()));
    if (!bio) return false;

    EVP_PKEY* pkey = PEM_read_bio_PUBKEY(bio, nullptr, nullptr, nullptr);
    BIO_free(bio);
    if (!pkey) return false;

    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) {
        EVP_PKEY_free(pkey);
        return false;
    }

    bool result = false;
    if (EVP_DigestVerifyInit(ctx, nullptr, EVP_sha256(), nullptr, pkey) == 1) {
        if (EVP_DigestVerifyUpdate(ctx, data.data(), data.size()) == 1) {
            result = EVP_DigestVerifyFinal(ctx, signature.data(), signature.size()) == 1;
        }
    }

    EVP_MD_CTX_free(ctx);
    EVP_PKEY_free(pkey);
    return result;
}

bool LicenseCrypto::SignRSA(const std::vector<uint8_t>& data,
                             const std::vector<uint8_t>& private_key,
                             std::vector<uint8_t>& signature) {
    BIO* bio = BIO_new_mem_buf(private_key.data(), static_cast<int>(private_key.size()));
    if (!bio) return false;

    EVP_PKEY* pkey = PEM_read_bio_PrivateKey(bio, nullptr, nullptr, nullptr);
    BIO_free(bio);
    if (!pkey) return false;

    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) {
        EVP_PKEY_free(pkey);
        return false;
    }

    bool result = false;
    size_t sig_len = 0;

    if (EVP_DigestSignInit(ctx, nullptr, EVP_sha256(), nullptr, pkey) == 1) {
        if (EVP_DigestSignUpdate(ctx, data.data(), data.size()) == 1) {
            if (EVP_DigestSignFinal(ctx, nullptr, &sig_len) == 1) {
                signature.resize(sig_len);
                if (EVP_DigestSignFinal(ctx, signature.data(), &sig_len) == 1) {
                    signature.resize(sig_len);
                    result = true;
                }
            }
        }
    }

    EVP_MD_CTX_free(ctx);
    EVP_PKEY_free(pkey);
    return result;
}

// Linux implementation uses AES-256-CBC with HMAC-SHA256 for cross-platform
// compatibility with macOS (which uses CommonCrypto with the same scheme)
bool LicenseCrypto::Encrypt(const std::vector<uint8_t>& plaintext,
                             const std::vector<uint8_t>& key,
                             std::vector<uint8_t>& ciphertext,
                             std::vector<uint8_t>& iv,
                             std::vector<uint8_t>& tag) {
    if (key.size() != 32) return false;

    // Generate 16-byte IV for CBC mode (matching macOS)
    iv = RandomBytes(16);

    // Allocate space for ciphertext (may be larger due to padding)
    ciphertext.resize(plaintext.size() + EVP_MAX_BLOCK_LENGTH);

    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return false;

    bool result = false;
    int len = 0;
    int final_len = 0;

    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key.data(), iv.data()) == 1) {
        if (EVP_EncryptUpdate(ctx, ciphertext.data(), &len, plaintext.data(),
                               static_cast<int>(plaintext.size())) == 1) {
            if (EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &final_len) == 1) {
                ciphertext.resize(len + final_len);

                // Compute HMAC-SHA256 over IV + ciphertext (matching macOS)
                tag.resize(SHA256_DIGEST_LENGTH);
                std::vector<uint8_t> hmac_data;
                hmac_data.insert(hmac_data.end(), iv.begin(), iv.end());
                hmac_data.insert(hmac_data.end(), ciphertext.begin(), ciphertext.end());

                unsigned int hmac_len = SHA256_DIGEST_LENGTH;
                if (HMAC(EVP_sha256(), key.data(), static_cast<int>(key.size()),
                         hmac_data.data(), hmac_data.size(),
                         tag.data(), &hmac_len) != nullptr) {
                    result = true;
                }
            }
        }
    }

    EVP_CIPHER_CTX_free(ctx);
    return result;
}

bool LicenseCrypto::Decrypt(const std::vector<uint8_t>& ciphertext,
                             const std::vector<uint8_t>& key,
                             const std::vector<uint8_t>& iv,
                             const std::vector<uint8_t>& tag,
                             std::vector<uint8_t>& plaintext) {
    // Accept both 16-byte IV (CBC from macOS) and verify tag is SHA256 (32 bytes)
    if (key.size() != 32 || iv.size() != 16 || tag.size() != SHA256_DIGEST_LENGTH) return false;

    // Verify HMAC first (computed over IV + ciphertext) - matching macOS
    std::vector<uint8_t> computed_tag(SHA256_DIGEST_LENGTH);
    std::vector<uint8_t> hmac_data;
    hmac_data.insert(hmac_data.end(), iv.begin(), iv.end());
    hmac_data.insert(hmac_data.end(), ciphertext.begin(), ciphertext.end());

    unsigned int hmac_len = SHA256_DIGEST_LENGTH;
    if (HMAC(EVP_sha256(), key.data(), static_cast<int>(key.size()),
             hmac_data.data(), hmac_data.size(),
             computed_tag.data(), &hmac_len) == nullptr) {
        return false;
    }

    // Constant-time comparison of full tag
    volatile uint8_t diff = 0;
    for (size_t i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        diff |= computed_tag[i] ^ tag[i];
    }
    if (diff != 0) return false;

    // Decrypt using AES-256-CBC
    plaintext.resize(ciphertext.size() + EVP_MAX_BLOCK_LENGTH);

    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return false;

    bool result = false;
    int len = 0;
    int final_len = 0;

    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key.data(), iv.data()) == 1) {
        if (EVP_DecryptUpdate(ctx, plaintext.data(), &len, ciphertext.data(),
                               static_cast<int>(ciphertext.size())) == 1) {
            if (EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &final_len) == 1) {
                plaintext.resize(len + final_len);
                result = true;
            }
        }
    }

    EVP_CIPHER_CTX_free(ctx);
    return result;
}

std::vector<uint8_t> LicenseCrypto::SHA256(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> hash(SHA256_DIGEST_LENGTH);
    ::SHA256(data.data(), data.size(), hash.data());
    return hash;
}

std::vector<uint8_t> LicenseCrypto::RandomBytes(size_t length) {
    std::vector<uint8_t> bytes(length);
    RAND_bytes(bytes.data(), static_cast<int>(length));
    return bytes;
}

#endif  // OS_LINUX

std::string LicenseCrypto::SHA256Hex(const std::string& data) {
    std::vector<uint8_t> hash = SHA256(std::vector<uint8_t>(data.begin(), data.end()));
    std::ostringstream ss;
    for (uint8_t byte : hash) {
        ss << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(byte);
    }
    return ss.str();
}

std::string LicenseCrypto::GenerateUUID() {
    std::vector<uint8_t> bytes = RandomBytes(16);

    bytes[6] = (bytes[6] & 0x0F) | 0x40;
    bytes[8] = (bytes[8] & 0x3F) | 0x80;

    std::ostringstream ss;
    for (size_t i = 0; i < 16; ++i) {
        ss << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(bytes[i]);
        if (i == 3 || i == 5 || i == 7 || i == 9) ss << '-';
    }
    return ss.str();
}

std::vector<uint8_t> LicenseCrypto::DeriveKey(const std::string& password,
                                               const std::vector<uint8_t>& salt) {
    std::vector<uint8_t> key(32);

#if defined(OS_MACOS)
    CCKeyDerivationPBKDF(kCCPBKDF2,
                         password.c_str(), password.length(),
                         salt.data(), salt.size(),
                         kCCPRFHmacAlgSHA256,
                         100000,
                         key.data(), key.size());
#elif defined(OS_LINUX)
    PKCS5_PBKDF2_HMAC(password.c_str(), static_cast<int>(password.length()),
                       salt.data(), static_cast<int>(salt.size()),
                       100000,
                       EVP_sha256(),
                       static_cast<int>(key.size()), key.data());
#endif

    return key;
}

// ============================================================================
// Subscription Validation Implementation
// ============================================================================

// License server URL (set via CMake from .env)
#ifndef OWL_LICENSE_SERVER_URL
#define OWL_LICENSE_SERVER_URL "http://localhost:3034"
#endif

std::string LicenseManager::GetLicenseServerUrl() {
    // Can be overridden by environment variable
    const char* env_url = getenv("OWL_LICENSE_SERVER_URL");
    if (env_url && strlen(env_url) > 0) {
        return std::string(env_url);
    }
    return OWL_LICENSE_SERVER_URL;
}

SubscriptionStatus LicenseManager::GetSubscriptionStatus() const {
    return state_->subscription_status.load();
}

int64_t LicenseManager::GetNextCheckTimestamp() const {
    std::lock_guard<std::mutex> lock(state_->state_mutex);
    return state_->subscription_next_check;
}

int64_t LicenseManager::GetActivationTimestamp() const {
    std::lock_guard<std::mutex> lock(state_->state_mutex);
    return state_->subscription_activation_time;
}

bool LicenseManager::IsSubscriptionDue() const {
    std::lock_guard<std::mutex> lock(state_->state_mutex);

    if (!state_->data || state_->data->type != LicenseType::SUBSCRIPTION) {
        return false;
    }

    int64_t now = GetSecureTimestamp();

    // First run - needs activation
    if (state_->subscription_activation_time == 0) {
        return true;
    }

    // Check if monthly check is due
    return now >= state_->subscription_next_check;
}

int64_t LicenseManager::CalculateNextCheckTimestamp(int64_t activation_timestamp) const {
    // Calculate next check based on activation date
    // E.g., if activated January 3rd 11 AM, next check is February 3rd 11 AM
    int64_t now = GetSecureTimestamp();

    // Get the activation time of day and day of month
    time_t activation_time = static_cast<time_t>(activation_timestamp);
    struct tm activation_tm;
#if defined(OS_WINDOWS)
    localtime_s(&activation_tm, &activation_time);
#else
    localtime_r(&activation_time, &activation_tm);
#endif

    // Get current time
    time_t now_time = static_cast<time_t>(now);
    struct tm now_tm;
#if defined(OS_WINDOWS)
    localtime_s(&now_tm, &now_time);
#else
    localtime_r(&now_time, &now_tm);
#endif

    // Calculate next check: same day of month, next occurrence
    struct tm next_check_tm = activation_tm;

    // Start with current month
    next_check_tm.tm_year = now_tm.tm_year;
    next_check_tm.tm_mon = now_tm.tm_mon;

    // If the check day has passed this month, go to next month
    if (now_tm.tm_mday > activation_tm.tm_mday ||
        (now_tm.tm_mday == activation_tm.tm_mday &&
         now_tm.tm_hour * 3600 + now_tm.tm_min * 60 + now_tm.tm_sec >=
         activation_tm.tm_hour * 3600 + activation_tm.tm_min * 60 + activation_tm.tm_sec)) {
        next_check_tm.tm_mon++;
        if (next_check_tm.tm_mon > 11) {
            next_check_tm.tm_mon = 0;
            next_check_tm.tm_year++;
        }
    }

    // Handle months with fewer days
    next_check_tm.tm_isdst = -1;  // Let mktime figure it out
    time_t next_check_time = mktime(&next_check_tm);

    return static_cast<int64_t>(next_check_time);
}

bool LicenseManager::ValidateSubscription(const LicenseData& data) {
    if (data.type != LicenseType::SUBSCRIPTION) {
        return true;  // Non-subscription licenses don't need this check
    }

    // Load existing subscription state
    auto saved_state = SubscriptionStateStorage::LoadState();

    if (saved_state) {
        // Verify license ID matches
        if (saved_state->license_id != data.license_id) {
            // License changed, reset state
            SubscriptionStateStorage::DeleteState();
            saved_state.reset();
        }
    }

    int64_t now = GetSecureTimestamp();

    if (!saved_state) {
        // First activation - need to check server immediately
        state_->subscription_activation_time = now;
        state_->subscription_next_check = now;  // Check immediately
        state_->subscription_status = SubscriptionStatus::UNKNOWN;

        // Perform initial server check
        bool is_active = false;
        if (CheckSubscriptionServer(data.license_id, is_active)) {
            if (is_active) {
                state_->subscription_status = SubscriptionStatus::ACTIVE;
                state_->subscription_next_check = CalculateNextCheckTimestamp(now);
                UpdateSubscriptionState(SubscriptionStatus::ACTIVE, true);
                return true;
            } else {
                state_->subscription_status = SubscriptionStatus::INACTIVE;
                UpdateSubscriptionState(SubscriptionStatus::INACTIVE, true);
                return false;
            }
        } else {
            // Server unreachable on first activation - fail
            state_->subscription_status = SubscriptionStatus::SERVER_ERROR;
            return false;
        }
    }

    // Use cached state
    state_->subscription_activation_time = saved_state->activation_timestamp;
    state_->subscription_next_check = saved_state->next_check_timestamp;
    state_->subscription_status = saved_state->status;
    state_->subscription_consecutive_failures = saved_state->consecutive_failures;

    // Check if subscription is inactive
    if (saved_state->status == SubscriptionStatus::INACTIVE) {
        // On each run when inactive, check if reactivated
        bool is_active = false;
        if (CheckSubscriptionServer(data.license_id, is_active)) {
            if (is_active) {
                state_->subscription_status = SubscriptionStatus::ACTIVE;
                state_->subscription_consecutive_failures = 0;
                state_->subscription_next_check = CalculateNextCheckTimestamp(state_->subscription_activation_time);
                UpdateSubscriptionState(SubscriptionStatus::ACTIVE, true);
                return true;
            }
        }
        return false;  // Still inactive
    }

    // Check if monthly check is due
    if (now >= saved_state->next_check_timestamp) {
        bool is_active = false;
        if (CheckSubscriptionServer(data.license_id, is_active)) {
            if (is_active) {
                state_->subscription_status = SubscriptionStatus::ACTIVE;
                state_->subscription_consecutive_failures = 0;
                state_->subscription_next_check = CalculateNextCheckTimestamp(state_->subscription_activation_time);
                UpdateSubscriptionState(SubscriptionStatus::ACTIVE, true);
                return true;
            } else {
                state_->subscription_status = SubscriptionStatus::INACTIVE;
                UpdateSubscriptionState(SubscriptionStatus::INACTIVE, true);
                return false;
            }
        } else {
            // Server unreachable - apply grace period
            state_->subscription_consecutive_failures++;
            int64_t grace_end = saved_state->last_check_timestamp +
                               (saved_state->grace_period_days * 86400);

            if (now < grace_end) {
                // Still in grace period
                state_->subscription_status = SubscriptionStatus::SERVER_ERROR;
                UpdateSubscriptionState(SubscriptionStatus::SERVER_ERROR, false);
                LOG_WARN("License", "Subscription server unreachable, grace period active");
                return true;
            } else {
                // Grace period expired
                state_->subscription_status = SubscriptionStatus::INACTIVE;
                UpdateSubscriptionState(SubscriptionStatus::INACTIVE, false);
                LOG_ERROR("License", "Subscription grace period expired");
                return false;
            }
        }
    }

    // Not due for check yet, use cached status
    return saved_state->status == SubscriptionStatus::ACTIVE ||
           saved_state->status == SubscriptionStatus::SERVER_ERROR;
}

void LicenseManager::UpdateSubscriptionState(SubscriptionStatus status, bool server_check_success) {
    std::lock_guard<std::mutex> lock(state_->state_mutex);

    if (!state_->data) return;

    SubscriptionStateStorage::SubscriptionState new_state;
    new_state.license_id = state_->data->license_id;
    new_state.status = status;
    new_state.activation_timestamp = state_->subscription_activation_time;
    new_state.last_check_timestamp = server_check_success ? GetSecureTimestamp() : 0;
    new_state.next_check_timestamp = state_->subscription_next_check;
    new_state.check_interval_days = 30;  // Monthly
    new_state.consecutive_failures = state_->subscription_consecutive_failures;
    new_state.grace_period_days = state_->data->grace_period_days > 0 ?
                                   state_->data->grace_period_days : 7;

    // Load existing state to preserve last_check_timestamp if server failed
    auto existing = SubscriptionStateStorage::LoadState();
    if (existing && !server_check_success) {
        new_state.last_check_timestamp = existing->last_check_timestamp;
        new_state.server_signature = existing->server_signature;
    }

    SubscriptionStateStorage::SaveState(new_state);
}

bool LicenseManager::IsInGracePeriod() const {
    std::lock_guard<std::mutex> lock(state_->state_mutex);

    if (!state_->data || state_->data->type != LicenseType::SUBSCRIPTION) {
        return false;
    }

    auto saved_state = SubscriptionStateStorage::LoadState();
    if (!saved_state) return false;

    if (saved_state->status != SubscriptionStatus::SERVER_ERROR) {
        return false;
    }

    int64_t now = GetSecureTimestamp();
    int64_t grace_end = saved_state->last_check_timestamp +
                       (saved_state->grace_period_days * 86400);

    return now < grace_end;
}

LicenseStatus LicenseManager::CheckSubscription() {
    std::lock_guard<std::mutex> lock(state_->state_mutex);

    if (!state_->data || state_->data->type != LicenseType::SUBSCRIPTION) {
        return state_->status.load();
    }

    bool is_active = false;
    if (CheckSubscriptionServer(state_->data->license_id, is_active)) {
        if (is_active) {
            state_->subscription_status = SubscriptionStatus::ACTIVE;
            state_->subscription_consecutive_failures = 0;
            state_->subscription_next_check = CalculateNextCheckTimestamp(state_->subscription_activation_time);
            UpdateSubscriptionState(SubscriptionStatus::ACTIVE, true);
            return LicenseStatus::VALID;
        } else {
            state_->subscription_status = SubscriptionStatus::INACTIVE;
            state_->status = LicenseStatus::SUBSCRIPTION_INACTIVE;
            state_->valid = false;
            UpdateSubscriptionState(SubscriptionStatus::INACTIVE, true);
            return LicenseStatus::SUBSCRIPTION_INACTIVE;
        }
    } else {
        state_->subscription_consecutive_failures++;
        if (IsInGracePeriod()) {
            state_->subscription_status = SubscriptionStatus::SERVER_ERROR;
            UpdateSubscriptionState(SubscriptionStatus::SERVER_ERROR, false);
            return LicenseStatus::VALID;  // Grace period
        } else {
            state_->status = LicenseStatus::SUBSCRIPTION_CHECK_FAILED;
            return LicenseStatus::SUBSCRIPTION_CHECK_FAILED;
        }
    }
}

// ============================================================================
// Daily License Validation Check (for ALL license types)
// ============================================================================

bool LicenseManager::IsDailyCheckDue() const {
    // Load persisted state from subscription storage (reuses same storage)
    auto saved_state = SubscriptionStateStorage::LoadState();
    if (!saved_state) {
        // No state saved yet - check is due
        return true;
    }

    int64_t now = GetSecureTimestamp();
    int64_t last_check = saved_state->last_check_timestamp;

    // Check if 24 hours have passed
    return (now - last_check) >= LicenseState::DAILY_CHECK_INTERVAL;
}

bool LicenseManager::PerformDailyLicenseCheck(const LicenseData& data) {
    int64_t now = GetSecureTimestamp();

    LOG_DEBUG("License", "Performing daily license validation check");

    // Try to activate/validate with server
    int seat_count = 0, max_seats = 1;
    bool server_success = ActivateLicenseWithServer(data.license_id, seat_count, max_seats);

    if (server_success) {
        // Server check passed - license is still active
        state_->daily_check_last_timestamp = now;
        state_->daily_check_consecutive_failures = 0;
        UpdateDailyCheckState(true);
        LOG_DEBUG("License", "Daily license check passed. Seat " +
                 std::to_string(seat_count) + "/" + std::to_string(max_seats));
        return true;
    }

    // Server check failed
    state_->daily_check_consecutive_failures++;
    LOG_WARN("License", "Daily license check failed (attempt " +
             std::to_string(state_->daily_check_consecutive_failures) + ")");

    // Load last successful check time from persisted state
    auto saved_state = SubscriptionStateStorage::LoadState();
    int64_t last_successful_check = saved_state ? saved_state->last_check_timestamp : 0;

    // Check if we're still in grace period
    int64_t grace_end = last_successful_check +
                       (LicenseState::DAILY_CHECK_GRACE_DAYS * 86400);

    if (now < grace_end && last_successful_check > 0) {
        // Still in grace period - allow usage but don't update timestamp
        int64_t days_remaining = (grace_end - now) / 86400;
        LOG_WARN("License", "Server unreachable. Grace period: " +
                 std::to_string(days_remaining) + " days remaining");
        UpdateDailyCheckState(false);  // Don't update timestamp
        return true;
    }

    // Grace period expired or no previous successful check
    LOG_ERROR("License", "License validation failed - grace period expired or server unreachable");
    UpdateDailyCheckState(false);
    return false;
}

void LicenseManager::UpdateDailyCheckState(bool success) {
    // Reuse SubscriptionStateStorage to persist daily check state
    // This works for all license types

    if (!state_->data) return;

    SubscriptionStateStorage::SubscriptionState new_state;
    new_state.license_id = state_->data->license_id;

    // For non-subscription licenses, use ACTIVE status when check passes
    if (state_->data->type == LicenseType::SUBSCRIPTION) {
        new_state.status = state_->subscription_status.load();
    } else {
        new_state.status = success ? SubscriptionStatus::ACTIVE : SubscriptionStatus::SERVER_ERROR;
    }

    new_state.activation_timestamp = state_->subscription_activation_time > 0 ?
                                     state_->subscription_activation_time : GetSecureTimestamp();

    // Only update last_check_timestamp if server check was successful
    if (success) {
        new_state.last_check_timestamp = GetSecureTimestamp();
    } else {
        // Preserve previous last_check_timestamp
        auto existing = SubscriptionStateStorage::LoadState();
        new_state.last_check_timestamp = existing ? existing->last_check_timestamp : 0;
    }

    new_state.next_check_timestamp = new_state.last_check_timestamp + LicenseState::DAILY_CHECK_INTERVAL;
    new_state.check_interval_days = 1;  // Daily check
    new_state.consecutive_failures = state_->daily_check_consecutive_failures;
    new_state.grace_period_days = LicenseState::DAILY_CHECK_GRACE_DAYS;

    SubscriptionStateStorage::SaveState(new_state);
}

bool LicenseManager::CheckSubscriptionServer(const std::string& license_id, bool& is_active) {
    is_active = false;

    std::string server_url = GetLicenseServerUrl();
    if (server_url.empty()) {
        LOG_ERROR("License", "No license server URL configured");
        return false;
    }

    // Build request URL
    std::string url = server_url + "/api/v1/subscription/check";

    // Create request payload with license_id, hardware fingerprint, and device metadata
    std::string hw_fingerprint = HardwareFingerprint::Generate();
    std::string device_name = EscapeJsonString(GetDeviceName());
    std::string os_info = EscapeJsonString(GetOSInfo());
    std::string browser_version = EscapeJsonString(GetBrowserVersion());

    std::string request_data = "{\"license_id\":\"" + license_id +
                               "\",\"hardware_fingerprint\":\"" + hw_fingerprint +
                               "\",\"device_name\":\"" + device_name +
                               "\",\"os_info\":\"" + os_info +
                               "\",\"browser_version\":\"" + browser_version +
                               "\",\"timestamp\":" + std::to_string(GetSecureTimestamp()) + "}";

    // Generate authenticated nonce for replay protection
    // Format: random_bytes(16) + HMAC-SHA256(random_bytes + timestamp + license_id, secret)
    // This proves the request came from an authentic browser with the shared secret
    std::vector<uint8_t> nonce_random = LicenseCrypto::RandomBytes(16);
    int64_t timestamp = GetSecureTimestamp();

    // Build data to sign: random bytes (hex) + timestamp (decimal) + license_id
    std::ostringstream sign_data;
    for (uint8_t b : nonce_random) {
        sign_data << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
    }
    sign_data << std::dec << timestamp << license_id;  // Switch to decimal for timestamp
    std::string data_to_sign = sign_data.str();

    // Get HMAC secret from compile-time definition
#ifndef OWL_NONCE_HMAC_SECRET
#define OWL_NONCE_HMAC_SECRET "change-this-in-production-insecure-default-key!"
#endif
    std::string hmac_secret = OWL_NONCE_HMAC_SECRET;

    // Compute HMAC-SHA256
    std::vector<uint8_t> hmac_result(32);
#if defined(OS_MACOS)
    CCHmac(kCCHmacAlgSHA256,
           hmac_secret.data(), hmac_secret.size(),
           data_to_sign.data(), data_to_sign.size(),
           hmac_result.data());
#elif defined(OS_LINUX)
    unsigned int hmac_len = 32;
    HMAC(EVP_sha256(),
         hmac_secret.data(), static_cast<int>(hmac_secret.size()),
         reinterpret_cast<const unsigned char*>(data_to_sign.data()), data_to_sign.size(),
         hmac_result.data(), &hmac_len);
#endif

    // Build nonce header: random_hex.timestamp.hmac_hex
    std::ostringstream nonce_hex;
    for (uint8_t b : nonce_random) {
        nonce_hex << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
    }
    nonce_hex << "." << std::dec << timestamp << ".";  // Switch back to decimal for timestamp
    for (uint8_t b : hmac_result) {
        nonce_hex << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
    }

    CURL* curl = curl_easy_init();
    if (!curl) {
        LOG_ERROR("License", "Failed to initialize CURL");
        return false;
    }

    std::string response_data;
    auto write_callback = [](char* ptr, size_t size, size_t nmemb, void* userdata) -> size_t {
        std::string* response = static_cast<std::string*>(userdata);
        response->append(ptr, size * nmemb);
        return size * nmemb;
    };

    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_POST, 1L);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, request_data.c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION,
                     static_cast<size_t(*)(char*, size_t, size_t, void*)>(write_callback));
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 10L);

    // Set headers
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, "Content-Type: application/json");
    headers = curl_slist_append(headers, ("X-Nonce: " + nonce_hex.str()).c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

    // SSL settings for production
    if (server_url.find("https://") == 0) {
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
        // Certificate pinning would be added here for production
    }

    CURLcode res = curl_easy_perform(curl);

    long http_code = 0;
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

    curl_slist_free_all(headers);
    curl_easy_cleanup(curl);

    if (res != CURLE_OK) {
        LOG_ERROR("License", "Server request failed: " + std::string(curl_easy_strerror(res)));
        return false;
    }

    if (http_code != 200) {
        LOG_ERROR("License", "Server returned HTTP " + std::to_string(http_code));
        return false;
    }

    // Parse response - expecting JSON: {"active": true/false, "signature": "..."}
    // The signature is RSA-signed by the server's private key
    // We verify it with the embedded public key

    // Helper to extract JSON string value
    auto extractJsonString = [&response_data](const std::string& key) -> std::string {
        std::string search = "\"" + key + "\":";
        size_t pos = response_data.find(search);
        if (pos == std::string::npos) return "";
        size_t start = pos + search.length();
        // Skip whitespace and opening quote
        while (start < response_data.length() &&
               (response_data[start] == ' ' || response_data[start] == '\n')) {
            start++;
        }
        if (start >= response_data.length() || response_data[start] != '"') return "";
        start++; // Skip opening quote
        size_t end = response_data.find("\"", start);
        if (end == std::string::npos) return "";
        return response_data.substr(start, end - start);
    };

    // Helper to extract JSON number value
    auto extractJsonNumber = [&response_data](const std::string& key) -> int64_t {
        std::string search = "\"" + key + "\":";
        size_t pos = response_data.find(search);
        if (pos == std::string::npos) return 0;
        size_t start = pos + search.length();
        // Skip whitespace
        while (start < response_data.length() &&
               (response_data[start] == ' ' || response_data[start] == '\n')) {
            start++;
        }
        size_t end = start;
        while (end < response_data.length() &&
               (isdigit(response_data[end]) || response_data[end] == '-')) {
            end++;
        }
        if (end == start) return 0;
        return std::stoll(response_data.substr(start, end - start));
    };

    // Helper to extract JSON bool value
    auto extractJsonBool = [&response_data](const std::string& key) -> bool {
        std::string search = "\"" + key + "\":";
        size_t pos = response_data.find(search);
        if (pos == std::string::npos) return false;
        size_t start = pos + search.length();
        // Skip whitespace
        while (start < response_data.length() && response_data[start] == ' ') {
            start++;
        }
        return response_data[start] == 't';
    };

    // Parse response fields
    size_t active_pos = response_data.find("\"active\":");
    if (active_pos == std::string::npos) {
        LOG_ERROR("License", "Invalid server response format");
        return false;
    }

    is_active = extractJsonBool("active");
    std::string signature_b64 = extractJsonString("signature");
    std::string resp_license_id = extractJsonString("license_id");
    int64_t next_check = extractJsonNumber("next_check_timestamp");
    int64_t grace_period = extractJsonNumber("grace_period_days");
    int64_t server_timestamp = extractJsonNumber("server_timestamp");

    // Verify signature if present
    if (!signature_b64.empty()) {
        // Base64 decode the signature
        auto b64_decode = [](const std::string& encoded) -> std::vector<uint8_t> {
            static const char b64_chars[] =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            std::vector<uint8_t> decoded;
            std::vector<int> T(256, -1);
            for (int i = 0; i < 64; i++) T[static_cast<unsigned char>(b64_chars[i])] = i;

            int val = 0, bits = -8;
            for (unsigned char c : encoded) {
                if (c == '=') break;
                if (T[c] == -1) continue;
                val = (val << 6) + T[c];
                bits += 6;
                if (bits >= 0) {
                    decoded.push_back(static_cast<uint8_t>((val >> bits) & 0xFF));
                    bits -= 8;
                }
            }
            return decoded;
        };

        std::vector<uint8_t> signature = b64_decode(signature_b64);

        if (!signature.empty()) {
            // Build canonical JSON string that was signed (same format as server)
            // Server signs: {"active":bool,"grace_period_days":int,"license_id":"str","next_check_timestamp":int,"server_timestamp":int}
            std::ostringstream canonical;
            canonical << "{\"active\":" << (is_active ? "true" : "false")
                     << ",\"grace_period_days\":" << grace_period
                     << ",\"license_id\":\"" << resp_license_id << "\""
                     << ",\"next_check_timestamp\":" << next_check
                     << ",\"server_timestamp\":" << server_timestamp << "}";

            std::string data_str = canonical.str();
            std::vector<uint8_t> data_bytes(data_str.begin(), data_str.end());

            // Get public key and verify
            std::vector<uint8_t> public_key = GetPublicKey();
            if (!LicenseCrypto::VerifyRSA(data_bytes, signature, public_key)) {
                LOG_ERROR("License", "Server response signature verification failed");
                return false;
            }

            LOG_DEBUG("License", "Server response signature verified");
        }
    } else {
        // No signature - reject in production, allow in development
#ifndef NDEBUG
        LOG_WARN("License", "Server response has no signature (dev mode)");
#else
        LOG_ERROR("License", "Server response missing signature");
        return false;
#endif
    }

    return true;
}

bool LicenseManager::ValidateServerCertificate(const std::string& hostname) {
    // This would implement certificate pinning for production
    // For now, return true to allow connection
    (void)hostname;
    return true;
}

// ============================================================================
// Universal License Activation (for ALL license types)
// ============================================================================

bool LicenseManager::ActivateLicenseWithServer(const std::string& license_id, int& seat_count, int& max_seats) {
    seat_count = 0;
    max_seats = 1;

    std::string server_url = GetLicenseServerUrl();
    if (server_url.empty()) {
        LOG_WARN("License", "No license server URL configured, skipping activation");
        return true;  // Allow offline activation if no server configured
    }

    // Build request URL
    std::string url = server_url + "/api/v1/license/activate";

    // Create request payload with license_id, hardware fingerprint, and device metadata
    std::string hw_fingerprint = HardwareFingerprint::Generate();
    std::string device_name = EscapeJsonString(GetDeviceName());
    std::string os_info = EscapeJsonString(GetOSInfo());
    std::string browser_version = EscapeJsonString(GetBrowserVersion());

    std::string request_data = "{\"license_id\":\"" + license_id +
                               "\",\"hardware_fingerprint\":\"" + hw_fingerprint +
                               "\",\"device_name\":\"" + device_name +
                               "\",\"os_info\":\"" + os_info +
                               "\",\"browser_version\":\"" + browser_version + "\"}";

    // Generate authenticated nonce for replay protection
    std::vector<uint8_t> nonce_random = LicenseCrypto::RandomBytes(16);
    int64_t timestamp = GetSecureTimestamp();

    // Build data to sign: random bytes (hex) + timestamp (decimal) + license_id
    std::ostringstream sign_data;
    for (uint8_t b : nonce_random) {
        sign_data << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
    }
    sign_data << std::dec << timestamp << license_id;  // Switch to decimal for timestamp
    std::string data_to_sign = sign_data.str();

    // Get HMAC secret from compile-time definition
#ifndef OWL_NONCE_HMAC_SECRET
#define OWL_NONCE_HMAC_SECRET "change-this-in-production-insecure-default-key!"
#endif
    std::string hmac_secret = OWL_NONCE_HMAC_SECRET;

    // Compute HMAC-SHA256
    std::vector<uint8_t> hmac_result(32);
#if defined(OS_MACOS)
    CCHmac(kCCHmacAlgSHA256,
           hmac_secret.data(), hmac_secret.size(),
           data_to_sign.data(), data_to_sign.size(),
           hmac_result.data());
#elif defined(OS_LINUX)
    unsigned int hmac_len = 32;
    HMAC(EVP_sha256(),
         hmac_secret.data(), static_cast<int>(hmac_secret.size()),
         reinterpret_cast<const unsigned char*>(data_to_sign.data()), data_to_sign.size(),
         hmac_result.data(), &hmac_len);
#endif

    // Build nonce header: random_hex.timestamp.hmac_hex
    std::ostringstream nonce_hex;
    for (uint8_t b : nonce_random) {
        nonce_hex << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
    }
    nonce_hex << "." << std::dec << timestamp << ".";  // Switch back to decimal for timestamp
    for (uint8_t b : hmac_result) {
        nonce_hex << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
    }

    CURL* curl = curl_easy_init();
    if (!curl) {
        LOG_ERROR("License", "Failed to initialize CURL for activation");
        return false;
    }

    std::string response_data;
    auto write_callback = [](char* ptr, size_t size, size_t nmemb, void* userdata) -> size_t {
        std::string* response = static_cast<std::string*>(userdata);
        response->append(ptr, size * nmemb);
        return size * nmemb;
    };

    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_POST, 1L);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, request_data.c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION,
                     static_cast<size_t(*)(char*, size_t, size_t, void*)>(write_callback));
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 10L);

    // Set headers
    struct curl_slist* headers = nullptr;
    headers = curl_slist_append(headers, "Content-Type: application/json");
    headers = curl_slist_append(headers, ("X-Nonce: " + nonce_hex.str()).c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

    // SSL settings for production
    if (server_url.find("https://") == 0) {
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
    }

    CURLcode res = curl_easy_perform(curl);

    long http_code = 0;
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

    curl_slist_free_all(headers);
    curl_easy_cleanup(curl);

    if (res != CURLE_OK) {
        LOG_ERROR("License", "Activation server request failed: " + std::string(curl_easy_strerror(res)));
        return false;
    }

    if (http_code != 200) {
        LOG_ERROR("License", "Activation server returned HTTP " + std::to_string(http_code));
        // Check if there's an error message in the response
        size_t error_pos = response_data.find("\"error\":");
        if (error_pos != std::string::npos) {
            size_t start = response_data.find("\"", error_pos + 8);
            size_t end = response_data.find("\"", start + 1);
            if (start != std::string::npos && end != std::string::npos) {
                std::string error_msg = response_data.substr(start + 1, end - start - 1);
                LOG_ERROR("License", "Server error: " + error_msg);
            }
        }
        return false;
    }

    // Parse response
    // Helper to extract JSON string value
    auto extractJsonString = [&response_data](const std::string& key) -> std::string {
        std::string search = "\"" + key + "\":";
        size_t pos = response_data.find(search);
        if (pos == std::string::npos) return "";
        size_t start = pos + search.length();
        // Skip whitespace and opening quote
        while (start < response_data.length() &&
               (response_data[start] == ' ' || response_data[start] == '\n')) {
            start++;
        }
        if (start >= response_data.length() || response_data[start] != '"') return "";
        start++; // Skip opening quote
        size_t end = response_data.find("\"", start);
        if (end == std::string::npos) return "";
        return response_data.substr(start, end - start);
    };

    // Helper to extract JSON number value
    auto extractJsonNumber = [&response_data](const std::string& key) -> int64_t {
        std::string search = "\"" + key + "\":";
        size_t pos = response_data.find(search);
        if (pos == std::string::npos) return 0;
        size_t start = pos + search.length();
        // Skip whitespace
        while (start < response_data.length() &&
               (response_data[start] == ' ' || response_data[start] == '\n')) {
            start++;
        }
        size_t end = start;
        while (end < response_data.length() &&
               (isdigit(response_data[end]) || response_data[end] == '-')) {
            end++;
        }
        if (end == start) return 0;
        return std::stoll(response_data.substr(start, end - start));
    };

    // Helper to extract JSON bool value
    auto extractJsonBool = [&response_data](const std::string& key) -> bool {
        std::string search = "\"" + key + "\":";
        size_t pos = response_data.find(search);
        if (pos == std::string::npos) return false;
        size_t start = pos + search.length();
        // Skip whitespace
        while (start < response_data.length() && response_data[start] == ' ') {
            start++;
        }
        return response_data[start] == 't';
    };

    // Parse response fields
    bool activated = extractJsonBool("activated");
    seat_count = static_cast<int>(extractJsonNumber("seat_count"));
    max_seats = static_cast<int>(extractJsonNumber("max_seats"));
    std::string signature_b64 = extractJsonString("signature");
    std::string resp_license_id = extractJsonString("license_id");
    std::string license_type_name = extractJsonString("license_type_name");
    int64_t server_timestamp = extractJsonNumber("server_timestamp");

    // Verify signature if present
    if (!signature_b64.empty()) {
        // Base64 decode the signature
        auto b64_decode = [](const std::string& encoded) -> std::vector<uint8_t> {
            static const char b64_chars[] =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            std::vector<uint8_t> decoded;
            std::vector<int> T(256, -1);
            for (int i = 0; i < 64; i++) T[static_cast<unsigned char>(b64_chars[i])] = i;

            int val = 0, bits = -8;
            for (unsigned char c : encoded) {
                if (c == '=') break;
                if (T[c] == -1) continue;
                val = (val << 6) + T[c];
                bits += 6;
                if (bits >= 0) {
                    decoded.push_back(static_cast<uint8_t>((val >> bits) & 0xFF));
                    bits -= 8;
                }
            }
            return decoded;
        };

        std::vector<uint8_t> signature = b64_decode(signature_b64);

        if (!signature.empty()) {
            // Build canonical JSON string that was signed (same format as server)
            // Server uses json.dumps(data, sort_keys=True, separators=(',', ':'))
            // So keys must be in alphabetical order, no spaces

            // Check for subscription-specific fields (grace_period_days, next_check_timestamp)
            int64_t grace_period = extractJsonNumber("grace_period_days");
            int64_t next_check = extractJsonNumber("next_check_timestamp");
            bool has_grace_period = (response_data.find("\"grace_period_days\":") != std::string::npos);
            bool has_next_check = (response_data.find("\"next_check_timestamp\":") != std::string::npos);

            std::ostringstream canonical;
            canonical << "{\"activated\":" << (activated ? "true" : "false")
                     << ",\"activation_timestamp\":" << extractJsonNumber("activation_timestamp");

            // grace_period_days comes before license_id alphabetically
            if (has_grace_period) {
                canonical << ",\"grace_period_days\":" << grace_period;
            }

            canonical << ",\"license_id\":\"" << resp_license_id << "\""
                     << ",\"license_type\":" << extractJsonNumber("license_type")
                     << ",\"license_type_name\":\"" << license_type_name << "\""
                     << ",\"max_seats\":" << max_seats;

            // next_check_timestamp comes after max_seats alphabetically
            if (has_next_check) {
                canonical << ",\"next_check_timestamp\":" << next_check;
            }

            canonical << ",\"seat_count\":" << seat_count
                     << ",\"server_timestamp\":" << server_timestamp << "}";

            std::string data_str = canonical.str();
            std::vector<uint8_t> data_bytes(data_str.begin(), data_str.end());

            // Get public key and verify
            std::vector<uint8_t> public_key = GetPublicKey();
            if (!LicenseCrypto::VerifyRSA(data_bytes, signature, public_key)) {
                LOG_ERROR("License", "Activation response signature verification failed");
                return false;
            }

            LOG_DEBUG("License", "Activation response signature verified");
        }
    } else {
        // No signature - reject in production, allow in development
#ifndef NDEBUG
        LOG_WARN("License", "Activation response has no signature (dev mode)");
#else
        LOG_ERROR("License", "Activation response missing signature");
        return false;
#endif
    }

    if (!activated) {
        std::string error_msg = extractJsonString("error");
        LOG_ERROR("License", "Activation failed: " + (error_msg.empty() ? "unknown error" : error_msg));
        return false;
    }

    LOG_DEBUG("License", "License activated successfully. Seat " +
             std::to_string(seat_count) + "/" + std::to_string(max_seats) +
             " (" + license_type_name + ")");

    return true;
}

// ============================================================================
// Tampering Detection Reporting
// ============================================================================

void LicenseManager::ReportTamperingToServer(LicenseStatus tampering_type, const std::string& details) {
    // Map LicenseStatus to tampering type string for server
    std::string tampering_type_str;
    switch (tampering_type) {
        case LicenseStatus::DEBUG_DETECTED:
            tampering_type_str = "debugger";
            break;
        case LicenseStatus::TAMPERED:
            tampering_type_str = "code_patched";
            break;
        case LicenseStatus::CLOCK_MANIPULATED:
            tampering_type_str = "clock_manipulation";
            break;
        case LicenseStatus::INVALID_SIGNATURE:
            tampering_type_str = "signature_invalid";
            break;
        case LicenseStatus::HARDWARE_MISMATCH:
            tampering_type_str = "hardware_mismatch";
            break;
        case LicenseStatus::CORRUPTED:
            tampering_type_str = "state_corrupted";
            break;
        case LicenseStatus::REVOKED:
            tampering_type_str = "revoked";
            break;
        default:
            tampering_type_str = "generic";
            break;
    }

    // Get license ID if available
    std::string license_id;
    if (state_ && state_->data) {
        license_id = state_->data->license_id;
    } else {
        // Try to extract from license file if state not loaded
        std::string path = GetDefaultLicensePath();
        auto file = LicenseFile::LoadFromFile(path);
        if (file) {
            LicenseData data;
            if (DecryptLicenseData(*file, data)) {
                license_id = data.license_id;
            }
        }
    }

    if (license_id.empty()) {
        LOG_WARN("License", "Cannot report tampering: no license ID available");
        return;
    }

    // Run in a detached thread to not block the main execution
    std::thread([this, license_id, tampering_type_str, details]() {
        std::string server_url = GetLicenseServerUrl();
        if (server_url.empty()) {
            LOG_WARN("License", "Cannot report tampering: no server URL configured");
            return;
        }

        std::string url = server_url + "/api/v1/report-tampering";

        // Generate hardware fingerprint
        std::string hw_fingerprint = HardwareFingerprint::Generate();
        int64_t client_timestamp = GetSecureTimestamp();

        // Escape details for JSON
        std::string escaped_details = EscapeJsonString(details);

        // Build request payload
        std::string request_data = "{\"license_id\":\"" + license_id +
                                   "\",\"tampering_type\":\"" + tampering_type_str +
                                   "\",\"hardware_fingerprint\":\"" + hw_fingerprint +
                                   "\",\"client_timestamp\":" + std::to_string(client_timestamp) +
                                   ",\"details\":\"" + escaped_details + "\"}";

        // Generate authenticated nonce (same as other API calls)
        std::vector<uint8_t> nonce_random = LicenseCrypto::RandomBytes(16);
        int64_t timestamp = GetSecureTimestamp();

        std::ostringstream sign_data;
        for (uint8_t b : nonce_random) {
            sign_data << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
        }
        sign_data << std::dec << timestamp << license_id;
        std::string data_to_sign = sign_data.str();

#ifndef OWL_NONCE_HMAC_SECRET
#define OWL_NONCE_HMAC_SECRET "change-this-in-production-insecure-default-key!"
#endif
        std::string hmac_secret = OWL_NONCE_HMAC_SECRET;

        std::vector<uint8_t> hmac_result(32);
#if defined(OS_MACOS)
        CCHmac(kCCHmacAlgSHA256,
               hmac_secret.data(), hmac_secret.size(),
               data_to_sign.data(), data_to_sign.size(),
               hmac_result.data());
#elif defined(OS_LINUX)
        unsigned int hmac_len = 32;
        HMAC(EVP_sha256(),
             hmac_secret.data(), static_cast<int>(hmac_secret.size()),
             reinterpret_cast<const unsigned char*>(data_to_sign.data()), data_to_sign.size(),
             hmac_result.data(), &hmac_len);
#endif

        std::ostringstream nonce_hex;
        for (uint8_t b : nonce_random) {
            nonce_hex << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
        }
        nonce_hex << "." << std::dec << timestamp << ".";
        for (uint8_t b : hmac_result) {
            nonce_hex << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
        }

        CURL* curl = curl_easy_init();
        if (!curl) {
            LOG_WARN("License", "Failed to init CURL for tampering report");
            return;
        }

        std::string response_data;
        auto write_callback = [](char* ptr, size_t size, size_t nmemb, void* userdata) -> size_t {
            std::string* response = static_cast<std::string*>(userdata);
            response->append(ptr, size * nmemb);
            return size * nmemb;
        };

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_POST, 1L);
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, request_data.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION,
                         static_cast<size_t(*)(char*, size_t, size_t, void*)>(write_callback));
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);  // Short timeout - don't block
        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 5L);

        struct curl_slist* headers = nullptr;
        headers = curl_slist_append(headers, "Content-Type: application/json");
        headers = curl_slist_append(headers, ("X-Nonce: " + nonce_hex.str()).c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

        if (server_url.find("https://") == 0) {
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
            curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2L);
        }

        CURLcode res = curl_easy_perform(curl);

        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);

        curl_slist_free_all(headers);
        curl_easy_cleanup(curl);

        if (res == CURLE_OK && http_code == 200) {
            LOG_DEBUG("License", "Tampering report sent successfully (" + tampering_type_str + ")");
        } else {
            // Fail silently - don't alert attacker that report failed
            LOG_DEBUG("License", "Tampering report delivery attempted");
        }
    }).detach();
}

// ============================================================================
// Status to String Conversion
// ============================================================================

const char* LicenseStatusToString(LicenseStatus status) {
    switch (status) {
        case LicenseStatus::VALID: return "valid";
        case LicenseStatus::EXPIRED: return "expired";
        case LicenseStatus::INVALID_SIGNATURE: return "invalid_signature";
        case LicenseStatus::CORRUPTED: return "corrupted";
        case LicenseStatus::NOT_FOUND: return "not_found";
        case LicenseStatus::HARDWARE_MISMATCH: return "hardware_mismatch";
        case LicenseStatus::SEAT_EXCEEDED: return "seat_exceeded";
        case LicenseStatus::REVOKED: return "revoked";
        case LicenseStatus::TAMPERED: return "tampered";
        case LicenseStatus::CLOCK_MANIPULATED: return "clock_manipulated";
        case LicenseStatus::DEBUG_DETECTED: return "debug_detected";
        case LicenseStatus::SUBSCRIPTION_INACTIVE: return "subscription_inactive";
        case LicenseStatus::SUBSCRIPTION_CHECK_FAILED: return "subscription_check_failed";
        case LicenseStatus::INTERNAL_ERROR: return "internal_error";
        default: return "unknown";
    }
}

}  // namespace license
}  // namespace olib
